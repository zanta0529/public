
## **Encipher v3.0 開發計畫**

### 1\. 總體目標與版本定義

  * **新版本號**：`v3.0`。這是一個具備重大突破性變更 (Breaking Change) 的版本，不相容於 `v1.0` 和 `v2.0`。
  * **核心理念**：修正、標準化、明確化。解決所有在外部審查中被標記為「最高風險」和「核心缺陷」的問題。
  * **最終產物**：
    1.  一份更新後的 `encipher.html` 檔案，包含 v3.0 的完整實作。
    2.  一份全新的 `README.md` 技術規格文件，作為 v3.0 的官方標準。
    3.  一份包含多組測試案例的 `test-vectors.json` 檔案。

### 2\. 核心技術修改方案

我將針對專家們一致指出的三大問題，進行以下釜底抽薪的修改：

#### **2.1. AAD 標準化序列化 (Canonicalization) - 解決致命缺陷**

這是所有審查意見中風險最高的問題。為確保 AAD 在任何平台、任何語言下都能產生完全一致的位元組序列，我將實施「**遞迴鍵值字母序排序**」策略。

  * **修改目標函式**：`crypto._buildAad`。

  * **具體作法**：

    1.  在 `JSON.stringify` 之前，建立一個新的遞迴函式，該函式會遍歷 AAD 物件的所有層級。
    2.  在每一層物件中，都將其鍵 (key) 按照字母順序進行排序，然後再建構一個新的、已排序的物件。
    3.  最終，只對這個經過完全排序的物件執行 `JSON.stringify`。

  * **範例**：

      * **排序前 (不確定性)**：`{"version":2,"keyDerivation":{"name":"Argon2id","parallelism":4,"iterations":4},"encryptionName":"AES-GCM"}`
      * **排序後 (確定性)**：`{"encryptionName":"AES-GCM","keyDerivation":{"iterations":4,"name":"Argon2id","parallelism":4},"version":2}`
      * **結果**：此舉可 100% 保證任何遵循相同排序規則的第三方實作，都能產生位元組完全相同的 AAD，徹底根除此致命缺陷。

#### **2.2. 資料結構一致性統一**

為解決 `AES-GCM` 與 `ChaCha20-Poly1305` 資料結構不一致的問題，我將對 v3.0 的 JSON 結構進行以下標準化：

1.  **分離認證標籤 (Tag)**：

      * **決策**：`ChaCha20-Poly1305` 的認證標籤將從密文中分離，與 AES-GCM 一樣，存放在一個獨立的 `tag` 欄位中。
      * **v3.0 加密物件結構**：
        ```json
        "encryption": {
          "name": "ChaCha20-Poly1305",
          "nonce": "...",         // 不變
          "ciphertext": "...",    // 將只包含純密文
          "tag": "..."            // [新增] 16 位元組的認證標籤
        }
        ```
      * **影響**：這將使得第三方開發者的解密邏輯極度簡化，無論何種演算法，都從相同的欄位讀取密文和標籤，無需再進行條件判斷或手動分割位元組。

2.  **統一隨機數命名**：

      * **決策**：根據專家建議，將 `AES-GCM` 的 `iv` (初始向量) 欄位名統一為 `nonce` (Number used once)，因為在 AEAD 的語境下 `nonce` 是更精確的術語。
      * **v3.0 加密物件結構**：
        ```json
        "encryption": {
          "name": "AES-GCM",
          "nonce": "...",         // [變更] 原 iv 欄位
          "ciphertext": "...",    // 不變
          "tag": "..."            // 不變
        }
        ```

#### **2.3. 程式碼重構與精簡**

  * **移除回溯相容邏輯**：
      * 根據指示，我將徹底移除 `crypto.decryptUnified` 函式中所有關於 `version != 2` 的判斷與 fallback 嘗試。
      * 解密流程將變得單一且明確：使用 AAD 進行解密，失敗即回報錯誤。
  * **更新加密與解密流程**：
      * **加密**：在 `crypto.encrypt` 中，針對 `ChaCha20-Poly1305`，需在加密後將密文與認證標籤分離，再存入 JSON 物件。
      * **解密**：在解密前，需先將 `ciphertext` 和 `tag` 欄位的 Base64 字串解碼後，合併成一個位元組陣列，再傳遞給 `ChaCha20-Poly1305` 的解密函式庫。

### 3\. 全新交付產物

#### **3.1. 官方測試向量 (Test Vectors)**

這是確保互操作性的關鍵。我將在開發完成後，使用 v3.0 版本的工具產生一份 `test-vectors.json` 檔案，其中包含至少 4 組完整的測試案例，涵蓋所有演算法組合：

  * **案例 1**: `Argon2id` + `AES-GCM`
  * **案例 2**: `Argon2id` + `ChaCha20-Poly1305`
  * **案例 3**: `PBKDF2` + `AES-GCM`
  * **案例 4**: `PBKDF2` + `ChaCha20-Poly1305`

每個案例都將包含：
`{ "description": "...", "password": "...", "plaintext": "...", "final_base64_output": "..." }`

#### **3.2. 更新版技術規格文件 (README.md)**

我將重寫 `README.md`，使其成為 v3.0 格式的唯一、權威的技術規格。內容將精確反映上述所有 AAD 規則與資料結構的變更。

### 4\. 開發與驗證工作流程

1.  **修改實作**：在 `encipher-legacy.html` 中實施 2.1, 2.2, 2.3 節描述的所有程式碼變更。
2.  **單元測試**：在本機進行完整的加解密流程測試，確保所有演算法組合在新規則下運作正常。
3.  **產出交付物**：使用功能完善的工具，正式產生 `test-vectors.json` 檔案。
4.  **獨立驗證 (關鍵步驟)**：我會編寫一個獨立的、極簡的 Node.js 腳本，該腳本**只**讀取 `test-vectors.json` 和 v3.0 的規格文件。它將使用標準的 Node.js 加密函式庫（如 `crypto`）來驗證每一組測試向量。**此步驟的成功，將證明 v3.0 格式是可被第三方可靠實作的。**
5.  **撰寫文件**：基於已驗證的實作，完成最終版 `README.md` 技術規格。

### 5\. 預期成果

完成此計畫後，Encipher 工具將：

  * 擁有一個雖然客製化、但**規則明確、行為確定**的加密格式。
  * 徹底解決外部專家提出的所有核心技術風險。
  * 大幅降低第三方開發者實現相容解密器的難度和出錯率。
  * 成為一個更穩健、更專業的純客戶端加密工具。