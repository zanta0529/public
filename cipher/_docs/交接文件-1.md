
## Encipher 加密工具專案交接文件

**文件目的**：本文檔旨在為後續接手的開發人員提供完整的專案背景、已完成的分析、探索過的技術路徑以及最終的建議方案，以實現無縫接軌。

### 1. 專案背景與初始狀態

本專案旨在開發一個名為 "Encipher" 的純客戶端加密工具。

* **初始版本**：v2.0
* **核心功能**：在瀏覽器本地對文字和檔案進行加密與解密。
* **技術特點**：
    * **加密格式**：採用一個客製化的 JSON 結構來封裝所有加密參數。
    * **加密演算法**：支援 `AES-256-GCM` 與 `ChaCha20-Poly1305` (均為 AEAD 演算法)。
    * **金鑰衍生函數 (KDF)**：支援 `Argon2id` 與 `PBKDF2`。
    * **認證附加資料 (AAD)**：將加密參數（如版本號、KDF 參數等）序列化為 JSON 字串，作為 AAD 以保護其完整性，防止參數竄改。

### 2. 外部專家審查結論 (綜合五份 Review)

為了驗證初始設計的穩健性，我們引入了五位外部專家的審查。結論高度一致，可歸納如下：

#### **2.1 共識優點**

* **安全原則正確**：所有專家都高度肯定專案採用 AEAD 加密模式以及使用 AAD 保護元資料完整性的核心理念，認為這符合現代密碼學的最佳實踐。
* **演算法選擇現代**：選用的 `AES-256-GCM`, `ChaCha20-Poly1305`, `Argon2id` 均為目前業界的黃金標準。
* **參數透明**：將所有解密所需參數（Salt, IV 等）包含在輸出中的設計，使得加密結果是「自包含的 (self-contained)」，值得稱讚。

#### **2.2 共識風險與核心缺陷**

1.  **【最高風險】AAD 序列化不確定性**：
    * **問題**：所有專家一致指出，客製化 AAD 的最大缺陷是**沒有定義 JSON 物件鍵 (key) 的序列化順序**。
    * **影響**：不同的程式語言或函式庫在序列化同一個物件時，會產生位元組層面完全不同的字串，這將導致 AAD 認證百分之百失敗，使得第三方開發者**不可能**實作出可相容的解密器。這是此設計的**致命缺陷**。

2.  **客製化格式的脆弱性**：
    * **問題**：多位專家提到，相較於業界標準（如 PASETO, JWE），任何客製化的加密格式都更脆弱、維護成本更高，且更難獲得第三方信任。
    * **影響**：第三方開發者需要極其小心地閱讀我們的設計文件並「手動」實作所有細節，極易出錯。

3.  **API 與資料結構不一致**：
    * **問題**：`AES-GCM` 的認證標籤 (`tag`) 是獨立欄位，而 `ChaCha20-Poly1305` 的標籤則與密文合併，這增加了第三方實作的複雜度。

### 3. 解決方案探索歷程與最終僵局

基於專家的審查結論，我們決定放棄客製化格式，並嘗試遷移到 PASETO 標準協定。

1.  **初次嘗試 (PASETO v4)**：我們首選最新、最安全的 PASETO v4。但很快發現，官方的 `paseto` v4 函式庫主要為 Node.js 設計，**在公用 CDN 上沒有提供一個能直接在瀏覽器中、無需本地編譯環境即可運行的穩定版本**。
2.  **降級嘗試 (PASETO v2)**：我們轉而嘗試較舊但同樣安全的 PASETO v2。這引發了一系列連鎖問題：
    * **函式庫選擇困難**：`paseto` 官方 v3 函式庫（實作 v2 協定）在 CDN 上提供的檔案是為 Node.js 設計的 CommonJS 格式，無法直接用於瀏覽器。
    * **API 反覆出錯**：我們嘗試了社群的 `paseto-ts` 函式庫，但其 CDN 連結和 API 的不穩定性導致了多次的執行失敗。
3.  **最終僵局**：我們得出結論，**「無需本地編譯打包、直接從 CDN 引用」** 的專案限制，與 **「穩定使用 PASETO 這種現代標準函式庫」** 之間存在難以調和的技術衝突。

### 4. 未來可行路徑

基於以上所有探索，後續開發者有兩條清晰且可行的路徑可以選擇。

---

#### **【路徑 A】遷移至 PASETO v4 標準 (強烈建議)**

此路徑旨在徹底解決所有底層問題，打造一個專業、穩定的現代加密工具。

* **核心決策**：放棄「無需本地編譯」的限制，接受使用現代前端開發工具（如 Vite, Parcel）。
* **前置條件**：
    1.  在本機安裝 Node.js。
    2.  使用 `npm` (或 `yarn`, `pnpm`) 管理專案依賴。
* **執行步驟**：
    1.  **建立專案**：使用 `npm create vite@latest` 建立一個簡單的前端專案。
    2.  **安裝依賴**：透過 `npm install paseto argon2-browser js-base64 qrcode` 安裝所有必要的、官方的函式庫。
    3.  **重構程式碼**：將我們已經開發好的模組化檔案 (`encipher.html`, `css/style.css`, `js/ui-controller.js`, `lib/encipher-core-v4.0.js`) 放入 Vite 專案結構中。`import` 語句將由 Vite 自動處理，不再需要指向 CDN。
    4.  **開發與建置**：使用 `npm run dev` 進行本地開發，`npm run build` 打包出最終的靜態網頁檔案。
* **優點**：
    * ✅ **一勞永逸**：徹底解決所有函式庫依賴與載入問題。
    * ✅ **最高安全性**：能夠使用最新、最安全的 PASETO v4 標準。
    * ✅ **最佳實踐**：遵循現代網頁開發的標準流程，專案清晰、可維護。
    * ✅ **完美回應專家意見**：從根本上解決了所有關於標準化、AAD 處理的問題。

---

#### **【路徑 B】強化現有的客製化格式**

如果「無需任何開發工具、單一 HTML 即可執行」是不可動搖的最高優先級，則可選擇此路徑。

* **核心決策**：回歸並修復最初的 v2.0 客製化 JSON 格式。
* **執行步驟**：
    1.  **【必要】實現 AAD 標準化序列化**：
        * 修改加密與解密流程，在 `JSON.stringify` 之前，**必須遞迴地對所有物件的鍵(key)進行字母序排序**。這是確保 AAD 在任何平台都一致的唯一方法。
    2.  **【必要】統一資料結構**：
        * 修改 `ChaCha20-Poly1305` 的加密流程，將其認證標籤 (`tag`) 從密文中分離出來，使其擁有與 `AES-GCM` 相同的、獨立的 `tag` 欄位。
    3.  **【必要】提供官方測試向量 (Test Vectors)**：
        * 建立一份文件，提供至少 2-3 組完整的加密範例（包含明文、密碼、所有參數、最終 Base64 輸出），供第三方開發者驗證其解密實作的正確性。
* **優點**：
    * ✅ **極致的可攜性**：最終產物可以是一個單一的 HTML 檔案，無需伺服器或任何工具即可運行。
* **缺點**：
    * ❌ **依然是客製化格式**：互操作性差，需要額外且詳盡的文件來支持。
    * ❌ **實作風險高**：手動處理序列化與資料結構，容易出錯。
    * ❌ **信任成本高**：第三方系統可能不願意花費額外精力來支援一個非標準的加密格式。

### 5. 結論與建議

本專案在密碼學理論的應用上具有良好基礎，但在工程實踐上遇到了由「專案限制」和「現代函式庫生態」衝突所引發的挑戰。

**我強烈建議後續開發者選擇【路徑 A】**。這不僅是技術上最正確、最穩健的選擇，也最符合專業軟體開發的標準流程。雖然增加了一點點環境設置的門檻，但它所換來的安全性、穩定性與未來可維護性是無可比擬的。