感謝您提供了詳細的設計文件！以下是針對文件中有關 **AAD (Authenticated Additional Data)** 部分的仔細檢視與分析，特別是其是否符合業界標準做法。我將從 AAD 的設計、實作細節、與業界標準的對比、潛在問題，以及改進建議等方面進行評估。

---

## AAD 設計分析

### 1. AAD 的用途與角色
AAD（認證附加資料）在認證加密（AEAD，Authenticated Encryption with Associated Data）模式（如 AES-GCM 和 ChaCha20-Poly1305）中，是一種不加密但其完整性受到保護的資料。文件中明確指出，AAD 用於防止對加密參數的惡意竄改，這是符合 AEAD 演算法核心設計目標的做法。AAD 的主要作用是確保以下內容的完整性：
- 加密參數（如演算法名稱、KDF 參數等）未被篡改。
- 解密時使用的參數與加密時一致。

文件中的 AAD 包含：
- 格式版本號 (`version`)。
- 非敏感的 KDF 參數（`name`, `iterations`, `memory`, `parallelism`, `hash`）。
- 加密演算法名稱（`encryptionName`）。

這些選擇反映了對關鍵元資料的保護，確保攻擊者無法修改這些參數（如將 Argon2id 改為 PBKDF2 或降低迭代次數）來削弱安全性。

### 2. AAD 建構規則
文件的 AAD 建構規則如下：
1. 從最終 JSON 結構中提取特定欄位（`version`, 非敏感 KDF 參數，`encryption.name`）。
2. 排除敏感欄位（如 `salt`），避免洩漏可能被用於暴力破解的資訊。
3. 將物件序列化為緊湊的 JSON 字串（無多餘空白），並轉為 UTF-8 編碼的位元組陣列。

這種方法有以下優點：
- **明確性**：AAD 的內容是結構化的 JSON 子集，易於重現，降低了實作錯誤的可能性。
- **最小化**：只包含必要參數，減少了不必要的資料暴露。
- **一致性**：使用緊湊 JSON 格式（無空白）確保跨平台序列化結果一致，這在密碼學中至關重要，因為 AAD 的任何位元差異都會導致認證失敗。

### 3. 與業界標準的對比
為了判斷 AAD 的設計是否符合業界標準，我們可以參考以下常見的 AEAD 應用場景和標準化協議（如 JWE、TLS、libsodium 等）：

#### a. 業界標準中的 AAD 使用
- **TLS (Transport Layer Security)**：
  - TLS 使用 AAD 來保護協議元資料（如序列號、協議版本等）。AAD 通常是二進位格式，包含必要的上下文資訊，確保傳輸的完整性。
  - 與本文件類似，TLS 的 AAD 不包含敏感資料，且嚴格要求一致性。
- **JWE (JSON Web Encryption)**：
  - JWE 在其 `protected` 頭部中包含元資料（如演算法名稱），這些資料以 Base64 編碼後作為 AAD 傳遞給 AEAD 演算法（如 AES-GCM）。
  - JWE 的 AAD 是緊湊 JSON 字串，與本文件的方法一致。
- **libsodium（密碼學庫）**：
  - 在使用 ChaCha20-Poly1305 或 AES-GCM 時，libsodium 允許應用程式自定義 AAD，通常是與密文相關的元資料（如版本號、標識符等）。
  - AAD 通常是任意位元組陣列，但 JSON 格式在應用層級常見。

本文件的 AAD 設計與 JWE 的做法最為接近，特別是將 AAD 定義為緊湊 JSON 字串並排除敏感資料（如 `salt`）。這與業界標準一致，特別是在 Web 應用場景中，JSON 是一種廣泛接受的結構化格式。

#### b. 使用的 AEAD 演算法
- 文件中支援的兩種 AEAD 演算法（AES-256-GCM 和 ChaCha20-Poly1305）均為業界標準，且被廣泛應用於 TLS、JWE 和其他安全協議中。
- **AES-GCM**：在 NIST 標準化（FIPS 197, SP 800-38D）中定義，廣泛應用於 TLS 1.2/1.3 和 JWE。
- **ChaCha20-Poly1305**：由 IETF 標準化（RFC 7539），在 TLS 1.3 和 WireGuard 等協議中廣泛使用，特別適合行動裝置和高效能場景。

兩者的 AAD 處理方式（作為輸入的一部分進行完整性驗證）完全符合其標準規範。

#### c. AAD 的內容選擇
- 業界實作中，AAD 通常包含與加密上下文相關的元資料，例如版本號、演算法標識、或非敏感的配置參數。本文件的 AAD 選擇（版本、KDF 參數、加密演算法名稱）與此一致。
- 排除 `salt` 是正確的做法，因為 `salt` 是敏感資料，包含在 AAD 中可能增加暴力破解的風險（雖然不直接洩漏密碼，但可能被用於預計算攻擊）。

### 4. 潛在問題與風險
儘管 AAD 的設計總體上符合業界標準，但以下幾點需要注意：

#### a. AAD 重建的複雜性
- AAD 的重建要求精確匹配（包括 JSON 序列化的順序和無空白格式）。這對開發者來說可能是一個挑戰，特別是在不同程式語言或 JSON 函式庫中，物件鍵的順序可能不保證一致。
- **風險**：如果第三方解密器未正確實現 `_buildAad` 函數的邏輯（例如，鍵順序不同或意外加入空白），可能導致認證失敗。
- **業界對比**：JWE 通過標準化的 Base64URL 編碼和規範化的 JSON 序列化避免了這類問題，但仍要求開發者嚴格遵循規範。

#### b. 回溯相容性處理
- 文件中提到對於舊版格式（`version != 2`）不使用 AAD，這是一個合理的過渡策略。然而，這種設計可能引入安全風險：
  - **風險**：如果攻擊者故意將 `version` 改為非 `2`，可能誘導解密器跳過 AAD 驗證，從而繞過對元資料的完整性檢查。
  - **業界做法**：TLS 和 JWE 等協議通常不允許完全禁用 AAD，而是通過版本協商來確保安全。文件中的回溯相容邏輯需要謹慎處理，以避免降級攻擊。

#### c. AAD 的單一用途
- 文件中的 AAD 僅用於保護元資料的完整性，未包含其他上下文資訊（如使用者 ID、時間戳等）。這在純客戶端工具中是合理的，但如果未來擴展到多使用者或伺服器場景，可能需要更豐富的 AAD 內容。
- **業界做法**：TLS 和 WireGuard 會在 AAD 中包含序列號或時間戳，以防止重放攻擊。本工具作為純客戶端應用，暫無此需求，但值得未來考慮。

### 5. 優點與符合標準之處
- **結構化 AAD**：使用 JSON 格式作為 AAD 是一種標準化且易於解析的做法，特別適合 Web 應用。JWE 和其他協議也廣泛採用類似方法。
- **排除敏感資料**：不將 `salt` 納入 AAD 符合密碼學最佳實務，避免了潛在的資訊洩漏。
- **明確的規範**：文件詳細描述了 AAD 的建構步驟，降低了第三方實作的歧義性。
- **支援標準演算法**：AES-GCM 和 ChaCha20-Poly1305 的 AAD 處理方式完全遵循其標準規範（NIST SP 800-38D 和 RFC 7539）。
- **向下相容性**：雖然存在潛在風險，但提供回溯相容性邏輯顯示了對實際應用的考量，這在業界中是常見的做法（如 TLS 的版本協商）。

### 6. 改進建議
為了進一步提升 AAD 設計的穩健性和與業界標準的對齊，以下是一些建議：
1. **標準化 JSON 鍵順序**：
   - 明確規定 AAD 物件的鍵順序（如按字母順序），並在文件中記錄，以確保不同程式語言的 JSON 序列化結果一致。
   - 或者，考慮在序列化後對 AAD 進行規範化處理（例如，使用規範 JSON，參考 JWE 的做法）。
2. **加強回溯相容性安全**：
   - 在解密舊版格式時，增加額外的安全檢查（如檢查密文的結構是否符合預期），以防止降級攻擊。
   - 考慮在未來版本中棄用無 AAD 的格式，強制要求 AAD。
3. **擴展 AAD 的上下文**：
   - 如果未來支援多使用者或伺服器場景，考慮在 AAD 中加入時間戳或唯一標識符，以防止重放攻擊。
4. **提供參考實作**：
   - 提供多語言的參考程式碼（例如 Python、Node.js）來展示 AAD 的正確重建，降低第三方開發者的實作難度。
5. **明確錯誤訊息**：
   - 在解密失敗時，提供更具體的錯誤訊息（如「AAD 不匹配」或「認證標籤無效」），幫助開發者診斷問題。

---

## 總結：是否為業界標準做法？
是的，文件的 AAD 設計**符合業界標準做法**，特別是在以下方面：
- 使用 JSON 格式作為 AAD，與 JWE 等標準化協議一致。
- 選擇 AES-GCM 和 ChaCha20-Poly1305 作為 AEAD 演算法，符合 NIST 和 IETF 標準。
- 排除敏感資料（如 `salt`）並保護元資料完整性，遵循密碼學最佳實務。
- 提供回溯相容性邏輯，顯示了對實際應用的考量。

然而，存在一些潛在改進空間，特別是在 JSON 序列化的規範化和回溯相容性的安全性方面。透過上述建議的調整，AAD 的設計可以進一步提升其穩健性和與業界標準的對齊。