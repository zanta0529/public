<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AES åŠ å¯†/è§£å¯†å·¥å…· (æ–‡å­—é‡‘é‘°/IV)</title>
    <style>
        body {
            transition: background-color 0.3s ease;
            font-family: Arial, sans-serif;
        }
        body.encrypt-mode {
            background-color: #e6ffe6;
        }
        body.decrypt-mode {
            background-color: #ffe6e6;
        }
        .container {
            max-width: 80%;
            margin: 20px auto;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .option-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .option {
            padding: 10px 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .option.selected {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        .option.disabled {
            pointer-events: none;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label, .label-text {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="text"],
        textarea {
            width: calc(100% - 22px); /* Adjusted for padding and border */
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
        }
        textarea {
             width: 98%; /* Original for textarea */
        }
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        .encryptButton {
            width: 100%;
            margin: 20px 0;
            background-color: #28a745; /* Green */
        }
        .encryptButton:hover {
            background-color: #1e7e34;
        }
        .decryptButton {
            width: 100%;
            margin: 20px 0;
            background-color: #dc3545; /* Red */
        }
        .decryptButton:hover {
            background-color: #b02a37;
        }
        #FunctionEncrypt,
        #FunctionDecrypt {
            background-color: #6c757d;
            border-width: 1px;
            color: white;
        }
        #FunctionEncrypt.selected,
        #FunctionDecrypt.selected {
            background-color: #BB3D00;
        }
        .note {
            color: #AE00AE;
            font-size: 14px;
            margin-top: 5px;
            margin-bottom: 10px;
        }
        .error-message {
            color: red;
            font-size: 16px;
        }
        .status-message {
            margin-top: 16px;
            padding: 10px;
            border-radius: 4px;
        }
        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .security-note {
            font-size: 0.9em;
            color: #721c24; /* Dark red */
            background-color: #f8d7da; /* Light red */
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            margin-bottom: 20px;
            border: 1px solid #f5c6cb;
        }
        @media (max-width: 768px) {
            .container {
                max-width: 95%;
            }
            .option {
                flex: 1 1 48%;
            }
            .button-group {
                flex-direction: column;
            }
        }
        @media (min-width: 769px) {
            .button-group {
                flex-direction: row;
                flex-wrap: wrap;
            }
            .button-group button {
                 flex: 1; /* Allow buttons to share space */
                 min-width: 100px; /* Minimum width for buttons */
            }
        }
    </style>
</head>
<body class="encrypt-mode">
    <div class="container">
        <h1>AES åŠ å¯†/è§£å¯†å·¥å…· (æ–‡å­—é‡‘é‘°/IV)</h1>

        <div id="functionMode" class="option-group">
            <div id="FunctionEncrypt" class="option selected" data-value="encrypt">åŠ å¯†æ¨¡å¼</div>
            <div id="FunctionDecrypt" class="option" data-value="decrypt">è§£å¯†æ¨¡å¼</div>
        </div>

        <div class="input-group">
            <label for="text">åŸå§‹æ–‡å­—ã€æ˜æ–‡ (Text)</label>
            <div class="button-group">
                <button onclick="copyText('text')">è¤‡è£½</button>
                <button onclick="pasteText('text')">è²¼ä¸Š</button>
                <button onclick="clearText('text')">æ¸…é™¤</button>
            </div>
            <textarea id="text" rows="6" placeholder="åœ¨æ­¤è¼¸å…¥è¦åŠ å¯†çš„æ˜æ–‡æˆ–è¦è§£å¯†çš„å¯†æ–‡"></textarea>
        </div>

        <label class="label-text">åŠ å¯†æ¼”ç®—æ³•æ¨¡å¼ (Encryption Mode)</label>
        <div id="encryptionMode" class="option-group">
            <div class="option selected" data-value="GCM">GCM</div>
            <div class="option" data-value="CTR">CTR</div>
            <div class="option" data-value="CBC">CBC</div>
            <div class="option" data-value="ECB">ECB</div>
        </div>
        <div class="security-note" id="ecbWarning" style="display: none;">
            ğŸ” <strong>æ³¨æ„ï¼š</strong>ECB æ¨¡å¼é€šå¸¸ä¸å®‰å…¨ï¼Œå› ç‚ºç›¸åŒçš„æ˜æ–‡å¡ŠæœƒåŠ å¯†æˆç›¸åŒçš„å¯†æ–‡å¡Šã€‚å»ºè­°åƒ…åœ¨ç‰¹æ®Šæƒ…æ³ä¸‹ä½¿ç”¨ã€‚
        </div>


        <div id="paddingGroup" style="display: none;">
            <label class="label-text">å¡«å……æ¨¡å¼ (Padding)</label>
            <div id="padding" class="option-group">
                <div class="option selected" data-value="Pkcs7">PKCS7</div>
                <div class="option" data-value="NoPadding">NoPadding</div>
            </div>
             <div class="note" id="noPaddingNote" style="display: none;">ğŸ” ä½¿ç”¨ NoPadding æ™‚ï¼ŒCBC / ECB æ¨¡å¼çš„æ˜æ–‡é•·åº¦ (UTF-8 ç·¨ç¢¼å¾Œçš„ä½å…ƒçµ„) å¿…é ˆæ˜¯ 16 çš„å€æ•¸ã€‚</div>
        </div>


        <label class="label-text">é‡‘é‘°é•·åº¦ (Encryption Key Size)</label>
        <div id="keySize" class="option-group">
            <div class="option selected" data-value="128">128 ä½å…ƒ</div>
            <div class="option" data-value="192">192 ä½å…ƒ</div>
            <div class="option" data-value="256">256 ä½å…ƒ</div>
        </div>

        <div class="input-group">
            <label for="secretKey">é‡‘é‘° (Secret Key) - ç´”æ–‡å­—æ ¼å¼</label>
            <input type="text" id="secretKey" placeholder="è¼¸å…¥é‡‘é‘°æ–‡å­—" />
            <div class="note">ğŸ” é‡‘é‘°æ–‡å­—å°‡ä»¥ UTF-8 ç·¨ç¢¼ã€‚ç·¨ç¢¼å¾Œçš„ <strong>* ä½å…ƒçµ„é•·åº¦ *</strong> éœ€ç¬¦åˆï¼š128 ä½å…ƒ (16 ä½å…ƒçµ„) | 192 ä½å…ƒ (24 ä½å…ƒçµ„) | 256 ä½å…ƒ (32 ä½å…ƒçµ„)ã€‚</div>
            <label id="msgKeyError" class="error-message"></label>
        </div>

        <div id="ivGroup" class="input-group">
            <label for="iv">åˆå§‹å‘é‡ (IV) - ç´”æ–‡å­—æ ¼å¼</label>
            <input type="text" id="iv" placeholder="è¼¸å…¥ IV æ–‡å­—" />
            <div class="note">
                ğŸ” GCMã€CTRã€CBC æ¨¡å¼éœ€è¦ IVã€‚IV æ–‡å­—å°‡ä»¥ UTF-8 ç·¨ç¢¼ï¼Œç·¨ç¢¼å¾Œçš„ <strong>* ä½å…ƒçµ„é•·åº¦ *</strong> é€šå¸¸éœ€ç‚º 16 ä½å…ƒçµ„ã€‚<br/>
                ğŸ” <strong>é‡è¦ï¼š</strong>GCM / CTRæ¨¡å¼ä¸‹ï¼ŒåŒä¸€é‡‘é‘°æ¯æ¬¡åŠ å¯†çš„ IV å¿…é ˆå”¯ä¸€ï¼CBC æ¨¡å¼ä¸‹ IV æ‡‰éš¨æ©Ÿä¸”ä¸å¯é æ¸¬ã€‚
            </div>
            <label id="msgIVError" class="error-message"></label>
        </div>

        <div id="tagLengthGroup" class="input-group" style="display: none;">
            <label class="label-text">èªè­‰æ¨™ç±¤é•·åº¦ (Tag Length for GCM)</label>
            <div id="tagLength" class="option-group">
                <div class="option selected" data-value="128">128 ä½å…ƒ</div>
                <div class="option" data-value="120">120 ä½å…ƒ</div>
                <div class="option" data-value="112">112 ä½å…ƒ</div>
                <div class="option" data-value="104">104 ä½å…ƒ</div>
                <div class="option" data-value="96">96 ä½å…ƒ</div>
            </div>
        </div>

        <div id="inputCiphertextFormatGroup" class="input-group" style="display: none;">
            <label class="label-text">è¼¸å…¥å¯†æ–‡æ ¼å¼ (Input Ciphertext Format)</label>
            <div id="inputCiphertextFormat" class="option-group">
                <div class="option selected" data-value="base64">Base64</div>
                <div class="option" data-value="hex">Hex</div>
            </div>
        </div>

        <label class="label-text">è¼¸å‡ºç´”æ–‡å­—æ ¼å¼ (Output Text Format)</label>
        <div id="outputFormat" class="option-group">
            <div id="optTextFormat" class="option" data-value="plaintext">æ˜æ–‡ (Plain-Text)</div>
            <div id="optBase64Format" class="option selected" data-value="base64">Base64</div>
            <div id="optHexFormat" class="option" data-value="hex">Hex</div>
        </div>


        <div class="button-group">
            <button id="btnExecute" onclick="processData()">åŠ å¯†</button>
        </div>

        <div class="input-group">
            <label for="result">çµæœ (Result)</label>
            <div class="button-group">
                <button onclick="copyText('result')">è¤‡è£½</button>
                <button onclick="clearText('result')">æ¸…é™¤</button>
                <button onclick="swapText()">äº¤æ›</button>
                <button onclick="resetForm">ğŸ” é‡ç½®</button>
            </div>
            <textarea id="result" rows="6" readonly></textarea>
        </div>

        <div id="status" class="status-message"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            document.getElementById("FunctionEncrypt").click();
            toggleUI();
            bindOptionGroupEvents();
        });

        const UI_CONFIG = [
            { mode: "GCM", padding: 0, keySize: 1, iv: 1, tagLength: 1 },
            { mode: "CTR", padding: 0, keySize: 1, iv: 1, tagLength: 0 },
            { mode: "CBC", padding: 1, keySize: 1, iv: 1, tagLength: 0 },
            { mode: "ECB", padding: 1, keySize: 1, iv: 0, tagLength: 0 },
        ];

        function toggleUI() {
            const func = getSelectedValue("functionMode");
            const mode = getSelectedValue("encryptionMode");
            const config = UI_CONFIG.find((c) => c.mode === mode);

            if (!config) {
                updateStatus(`æœªçŸ¥çš„åŠ å¯†æ¨¡å¼: '${mode}'`, true);
                return;
            }

            document.getElementById("paddingGroup").style.display = config.padding ? "block" : "none";
            document.getElementById("ivGroup").style.display = config.iv ? "block" : "none";
            // Removed maxlength for IV input: document.getElementById("iv").setAttribute("maxlength", config.iv ? 32 : 0);

            document.getElementById("tagLengthGroup").style.display = config.tagLength ? "block" : "none";
            document.getElementById("ecbWarning").style.display = (mode === "ECB") ? "block" : "none";

            if (config.padding) {
                 const paddingType = getSelectedValue("padding");
                 document.getElementById("noPaddingNote").style.display = (paddingType === "NoPadding") ? "block" : "none";
            } else {
                document.getElementById("noPaddingNote").style.display = "none";
            }

            const processButton = document.getElementById("btnExecute");
            processButton.textContent = func === "encrypt" ? "åŠ å¯† (Encrypt)" : "è§£å¯† (Decrypt)";
            processButton.className = func === "encrypt" ? "encryptButton" : "decryptButton";
            document.body.className = func === "encrypt" ? "encrypt-mode" : "decrypt-mode";

            document.getElementById("inputCiphertextFormatGroup").style.display = func === "decrypt" ? "block" : "none";

            const outputFormatGroup = document.getElementById("outputFormat");
            outputFormatGroup.querySelectorAll(".option").forEach((option) => option.classList.remove("selected"));
            let defaultOutputOptionValue;
            if (func === "encrypt") {
                document.getElementById("optTextFormat").style.display = "none";
                document.getElementById("optBase64Format").style.display = "block";
                document.getElementById("optHexFormat").style.display = "block";
                defaultOutputOptionValue = "base64";
            } else { // decrypt
                document.getElementById("optTextFormat").style.display = "block";
                document.getElementById("optBase64Format").style.display = "none";
                document.getElementById("optHexFormat").style.display = "none";
                defaultOutputOptionValue = "plaintext";
            }
            const defaultOptionElement = outputFormatGroup.querySelector(`[data-value='${defaultOutputOptionValue}']`);
            if (defaultOptionElement) defaultOptionElement.classList.add("selected");
            else if (outputFormatGroup.querySelector(".option")) outputFormatGroup.querySelector(".option").classList.add("selected");

            if (func === "decrypt") {
                const inputCiphertextFormatGroup = document.getElementById("inputCiphertextFormat");
                if (!inputCiphertextFormatGroup.querySelector(".option.selected")) {
                    inputCiphertextFormatGroup.querySelectorAll(".option").forEach(opt => opt.classList.remove("selected"));
                    inputCiphertextFormatGroup.querySelector("[data-value='base64']").classList.add("selected");
                }
            }
        }

        async function processData() {
            const func = getSelectedValue("functionMode");
            const mode = getSelectedValue("encryptionMode");
            const paddingValue = document.getElementById("paddingGroup").style.display !== "none" ? getSelectedValue("padding") : "NoPadding";
            const text = document.getElementById("text").value;
            const secretKeyText = document.getElementById("secretKey").value; // Text input
            const keySize = parseInt(getSelectedValue("keySize"));
            const ivText = document.getElementById("ivGroup").style.display !== "none" ? document.getElementById("iv").value : ""; // Text input
            const tagLength = document.getElementById("tagLengthGroup").style.display !== "none" ? parseInt(getSelectedValue("tagLength")) : 128;
            const outputFormat = getSelectedValue("outputFormat");
            const inputCiphertextFormat = func === "decrypt" ? getSelectedValue("inputCiphertextFormat") : null;

            document.getElementById("msgKeyError").textContent = "";
            document.getElementById("msgIVError").textContent = "";
            updateStatus("", false);

            const keyValidationError = validateSecretKey(secretKeyText, keySize);
            if (keyValidationError) return displayError(keyValidationError, "msgKeyError");

            const currentModeConfig = UI_CONFIG.find(c => c.mode === mode);
            if (currentModeConfig && currentModeConfig.iv) {
                const ivValidationError = validateInitialVector(ivText);
                if (ivValidationError) return displayError(ivValidationError, "msgIVError");
            }

            if (func === "encrypt" && (mode === "CBC" || mode === "ECB") && paddingValue === "NoPadding") {
                const plaintextBytes = new TextEncoder().encode(text);
                if (plaintextBytes.byteLength % 16 !== 0) {
                    updateStatus("è­¦å‘Šï¼šä½¿ç”¨ NoPadding æ™‚ï¼Œæ˜æ–‡ (UTF-8ç·¨ç¢¼å¾Œ) é•·åº¦æ‡‰ç‚º16ä½å…ƒçµ„çš„å€æ•¸ã€‚ç›®å‰é•·åº¦ï¼š" + plaintextBytes.byteLength + " ä½å…ƒçµ„ã€‚åŠ å¯†å¯èƒ½ç”¢ç”Ÿéé æœŸçµæœã€‚", true, "warning");
                }
            }

            try {
                let result;
                if (func === "encrypt") {
                    result = await performEncryption(
                        mode, text, secretKeyText, ivText, tagLength, paddingValue, outputFormat
                    );
                } else {
                    result = await performDecryption(
                        mode, text, secretKeyText, ivText, tagLength, paddingValue, inputCiphertextFormat
                    );
                    if ((mode === "CBC" || mode === "ECB") && result === "" && text.trim() !== "") {
                         updateStatus("è§£å¯†æˆåŠŸï¼Œä½†çµæœç‚ºç©ºã€‚å¦‚æœåŸå§‹æ˜æ–‡éç©ºï¼Œé€™å¯èƒ½è¡¨ç¤ºè§£å¯†å¤±æ•— (ä¾‹å¦‚é‡‘é‘°éŒ¯èª¤æˆ–å¯†æ–‡æå£)ã€‚", false, "warning-append");
                    }
                }
                document.getElementById("result").value = result;
                if (!document.getElementById("status").textContent.includes("è­¦å‘Š")) {
                     updateStatus(`${func === "encrypt" ? "åŠ å¯†" : "è§£å¯†"}æˆåŠŸ`, false);
                }
            } catch (error) {
                console.error("Processing Error:", error);
                updateStatus(`éŒ¯èª¤: ${error.message}`, true);
            }
        }

        async function performEncryption(mode, text, secretKeyText, ivText, tagLength, paddingValue, outputFormat) {
            const apiModeName = `AES-${mode.toUpperCase()}`;
            let keyBytesForWebCrypto, ivBytesForWebCrypto; // These will be Uint8Array

            if (mode === "GCM" || mode === "CTR") {
                keyBytesForWebCrypto = new TextEncoder().encode(secretKeyText);
                if (ivText) ivBytesForWebCrypto = new TextEncoder().encode(ivText);

                const cryptoKey = await window.crypto.subtle.importKey("raw", keyBytesForWebCrypto, { name: apiModeName }, false, ["encrypt"]);
                const algorithm = { name: apiModeName, iv: ivBytesForWebCrypto };
                if (mode === "GCM") algorithm.tagLength = tagLength;
                if (mode === "CTR") algorithm.counter = ivBytesForWebCrypto;

                const encryptedData = await window.crypto.subtle.encrypt(algorithm, cryptoKey, new TextEncoder().encode(text));
                if (outputFormat === "hex") return arrayBufferToHex(encryptedData);
                return arrayBufferToBase64(encryptedData);
            } else { // CBC or ECB using CryptoJS
                const key = CryptoJS.enc.Utf8.parse(secretKeyText); // Parse text as Utf8
                const iv = ivText ? CryptoJS.enc.Utf8.parse(ivText) : undefined;
                const config = {
                    mode: CryptoJS.mode[mode],
                    padding: CryptoJS.pad[paddingValue],
                    ...(iv && { iv: iv }),
                };
                const encrypted = CryptoJS.AES.encrypt(text, key, config);
                if (outputFormat === "hex") return encrypted.ciphertext.toString(CryptoJS.enc.Hex);
                return encrypted.toString();
            }
        }

        async function performDecryption(mode, text, secretKeyText, ivText, tagLength, paddingValue, inputCiphertextFormat) {
            const apiModeName = `AES-${mode.toUpperCase()}`;
            let dataToDecrypt; // ArrayBuffer for WebCrypto, specific format for CryptoJS

            // Prepare key/IV bytes
            let keyBytesForWebCrypto, ivBytesForWebCrypto;
            if (mode === "GCM" || mode === "CTR") {
                keyBytesForWebCrypto = new TextEncoder().encode(secretKeyText);
                if (ivText) ivBytesForWebCrypto = new TextEncoder().encode(ivText);
            }


            if (inputCiphertextFormat === "base64") {
                try { dataToDecrypt = base64ToArrayBuffer(text); }
                catch (e) { throw new Error("è¼¸å…¥çš„Base64å¯†æ–‡æ ¼å¼ç„¡æ•ˆã€‚"); }
            } else if (inputCiphertextFormat === "hex") {
                 try { dataToDecrypt = hexToArrayBuffer(text); }
                 catch (e) { throw new Error("è¼¸å…¥çš„Hexå¯†æ–‡æ ¼å¼ç„¡æ•ˆã€‚"); }
            } else {
                throw new Error("æœªçŸ¥çš„è¼¸å…¥å¯†æ–‡æ ¼å¼ã€‚");
            }

            if (mode === "GCM" || mode === "CTR") {
                const cryptoKey = await window.crypto.subtle.importKey("raw", keyBytesForWebCrypto, { name: apiModeName }, false, ["decrypt"]);
                const algorithm = { name: apiModeName, iv: ivBytesForWebCrypto };
                if (mode === "GCM") algorithm.tagLength = tagLength;
                if (mode === "CTR") algorithm.counter = ivBytesForWebCrypto;

                const decryptedData = await window.crypto.subtle.decrypt(algorithm, cryptoKey, dataToDecrypt);
                return new TextDecoder().decode(decryptedData);
            } else { // CBC or ECB using CryptoJS
                const key = CryptoJS.enc.Utf8.parse(secretKeyText);
                const iv = ivText ? CryptoJS.enc.Utf8.parse(ivText) : undefined;
                const config = {
                    mode: CryptoJS.mode[mode],
                    padding: CryptoJS.pad[paddingValue],
                    ...(iv && { iv: iv }),
                };

                let ciphertextForCryptoJS;
                // CryptoJS.AES.decrypt expects Base64 string or CipherParams object.
                // dataToDecrypt is currently an ArrayBuffer. Convert to Base64 for CryptoJS.
                if (inputCiphertextFormat === "base64") {
                     ciphertextForCryptoJS = text; // Original base64 string
                } else { // if input was hex, dataToDecrypt is ArrayBuffer. Convert to Base64 for CryptoJS.
                     ciphertextForCryptoJS = arrayBufferToBase64(dataToDecrypt);
                }

                const decrypted = CryptoJS.AES.decrypt(ciphertextForCryptoJS, key, config);
                try {
                    return decrypted.toString(CryptoJS.enc.Utf8);
                } catch (e) {
                    throw new Error("è§£å¯†æˆåŠŸï¼Œä½†çµæœç„¡æ³•æ­£ç¢ºè§£æç‚ºUTF-8æ–‡æœ¬ã€‚å¯èƒ½å¯†æ–‡å·²æå£æˆ–é‡‘é‘°/IV/æ¨¡å¼éŒ¯èª¤ã€‚");
                }
            }
        }

        function arrayBufferToBase64(buffer) {
            let binary = "";
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function arrayBufferToHex(buffer) {
            return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, "0")).join("");
        }
        
        function isHex(hexString) { // Helper for hexToArrayBuffer, though not directly used in validation path now
            return /^[0-9a-fA-F]+$/.test(hexString) && (hexString.length % 2 === 0);
        }

        function hexToArrayBuffer(hex) {
            if (!/^[0-9a-fA-F]+$/.test(hex) || hex.length % 2 !== 0) { // Basic hex validation
                 throw new Error("ç„¡æ•ˆçš„Hexå­—ä¸²: " + hex.substring(0,10) + "...");
            }
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
            }
            return bytes.buffer;
        }

        function bindOptionGroupEvents() {
            document.querySelectorAll(".option-group").forEach((group) => {
                group.addEventListener("click", (e) => {
                    const selectedOption = e.target.closest(".option");
                    if (selectedOption && !selectedOption.classList.contains("disabled")) {
                        group.querySelectorAll(".option").forEach((opt) => opt.classList.remove("selected"));
                        selectedOption.classList.add("selected");
                        if (group.id === "functionMode" || group.id === "encryptionMode" || group.id === "padding") {
                            toggleUI();
                        }
                    }
                });
            });
        }

        function getSelectedValue(groupId) {
            const selected = document.querySelector(`#${groupId} .option.selected`);
            return selected ? selected.dataset.value : null;
        }

        function copyText(id) {
            const element = document.getElementById(id);
            navigator.clipboard.writeText(element.value).then(() => {
                updateStatus("å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿", false);
            }).catch(err => {
                updateStatus("è¤‡è£½å¤±æ•—: " + err, true);
            });
        }

        async function pasteText(id) {
            try {
                const text = await navigator.clipboard.readText();
                document.getElementById(id).value = text;
            } catch (err) {
                updateStatus("è²¼ä¸Šå¤±æ•—: " + err, true);
            }
        }

        function clearText(id) {
            document.getElementById(id).value = "";
        }

        function swapText() {
            const textVal = document.getElementById("text").value;
            const resultVal = document.getElementById("result").value;
            document.getElementById("text").value = resultVal;
            document.getElementById("result").value = textVal;
            updateStatus("å·²äº¤æ›åŸå§‹æ–‡å­—èˆ‡çµæœæ–‡å­—", false);
        }

        function resetForm() {
            document.querySelectorAll("textarea, input[type='text']").forEach((input) => (input.value = ""));
            document.getElementById("msgKeyError").textContent = "";
            document.getElementById("msgIVError").textContent = "";
            updateStatus("", false); 

            document.getElementById("FunctionEncrypt").click(); 
            document.querySelector("#encryptionMode .option[data-value='GCM']").click();
            document.querySelector("#keySize .option[data-value='128']").click();
            const paddingPkcs7 = document.querySelector("#padding .option[data-value='Pkcs7']");
            if (paddingPkcs7) paddingPkcs7.click();
            const tagLength128 = document.querySelector("#tagLength .option[data-value='128']");
            if (tagLength128) tagLength128.click();
            const outputBase64 = document.querySelector("#outputFormat .option[data-value='base64']");
            if(outputBase64) outputBase64.click();
            const inputBase64 = document.querySelector("#inputCiphertextFormat .option[data-value='base64']");
            if(inputBase64) inputBase64.click();
            toggleUI(); 
        }

        function validateSecretKey(secretKeyText, keySize) {
            if (!secretKeyText) return "* é‡‘é‘°ç‚ºå¿…å¡«ã€‚";
            const keyBytes = new TextEncoder().encode(secretKeyText);
            const actualByteLength = keyBytes.byteLength;
            const requiredByteLength = keySize / 8;
            if (actualByteLength !== requiredByteLength) {
                return `* é‡‘é‘° (UTF-8ç·¨ç¢¼å¾Œ) ç‚º ${actualByteLength} ä½å…ƒçµ„ï¼Œä¸ç¬¦åˆé¸å®šé‡‘é‘°é•·åº¦æ‰€éœ€çš„ ${requiredByteLength} ä½å…ƒçµ„ã€‚è«‹èª¿æ•´è¼¸å…¥æ–‡å­—ã€‚`;
            }
            return null;
        }

        function validateInitialVector(ivText) {
            const REQUIRED_IV_BYTE_LENGTH = 16;
            if (!ivText && document.getElementById("ivGroup").style.display !== "none") { // Check if IV group is visible
                 // Only validate if IV is actually needed and visible
                 const currentMode = getSelectedValue("encryptionMode");
                 const config = UI_CONFIG.find(c => c.mode === currentMode);
                 if (config && config.iv) { // If current mode requires IV
                    return "* IV ç‚ºå¿…å¡«ã€‚";
                 }
            }
            if (ivText) { // If IV text is provided, validate its byte length
                const ivBytes = new TextEncoder().encode(ivText);
                const actualByteLength = ivBytes.byteLength;
                if (actualByteLength !== REQUIRED_IV_BYTE_LENGTH) {
                    return `* IV (UTF-8ç·¨ç¢¼å¾Œ) ç‚º ${actualByteLength} ä½å…ƒçµ„ï¼Œä¸ç¬¦åˆæ‰€éœ€çš„ ${REQUIRED_IV_BYTE_LENGTH} ä½å…ƒçµ„ã€‚è«‹èª¿æ•´è¼¸å…¥æ–‡å­—ã€‚`;
                }
            }
            return null;
        }

        function displayError(message, elementId) {
            const element = document.getElementById(elementId);
            if (element) element.textContent = message;
            updateStatus("è¼¸å…¥é©—è­‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥éŒ¯èª¤è¨Šæ¯ã€‚", true);
        }

        function updateStatus(message, isError, mode = "normal") { 
            const statusElement = document.getElementById("status");
            if (mode === "append" || mode === "warning-append") {
                statusElement.innerHTML += "<br>" + message;
                 if (mode === "warning-append") { 
                    if (!statusElement.className.includes("status-success")) statusElement.className = 'status-message status-success';
                 }
            } else {
                statusElement.textContent = message;
                if (message) {
                    statusElement.className = isError ? 'status-message status-error' : 'status-message status-success';
                     if (mode === "warning") { 
                         statusElement.className = 'status-message status-error'; 
                     }
                } else {
                    statusElement.className = 'status-message'; 
                }
            }
        }
    </script>
</body>
</html>
