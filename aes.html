<!DOCTYPE html>
<html lang="zh-Hant" data-theme="dark">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>AES 加解密工具</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
        <style>
            /* --- CSS 變數定義 (淺色 & 深色主題) --- */
            :root {
                --primary-color: #007bff;
                --primary-hover-color: #0056b3;
                --secondary-color: #6c757d;
                --secondary-hover-color: #5a6268;
                --danger-color: #dc3545;
                --danger-hover-color: #c82333;
                --success-btn-color: #28a745;
                --success-btn-hover-color: #218838;
                --warning-btn-bg-color: #ffc107;
                --warning-btn-text-color: #212529;
                --warning-btn-hover-bg-color: #e0a800;

                --bg-color: #f8f9fa;
                --container-bg: #ffffff;
                --text-color: #212529;
                --border-color: #dee2e6;
                --input-bg: #e9f5ff;
                --input-focus-shadow: rgba(0, 123, 255, 0.25);
                --button-disabled-bg: #ccc;
                --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
                --error-color: #721c24;
                --error-bg: #f8d7da;
                --success-color: #155724;
                --success-bg: #d4edda;
                --warning-color: #856404;
                --warning-bg: #fff3cd;
                --note-color: #083b06;
                --note-bg: #baf1ac;
                --toast-bg: #323232;
                --toast-color: #fff;
            }

            :root[data-theme="dark"] {
                --primary-color: #1e90ff;
                --primary-hover-color: #4ca8ff;
                --secondary-color: #778899;
                --secondary-hover-color: #90a0b1;
                --danger-color: #c82333;
                --danger-hover-color: #a71d2a;
                --success-btn-color: #20c997;
                --success-btn-hover-color: #1baa80;
                --warning-btn-bg-color: #fd7e14;
                --warning-btn-text-color: #ffffff;
                --warning-btn-hover-bg-color: #e66b04;

                --bg-color: #1e1e2f;
                --container-bg: #2f2f4f;
                --text-color: #e8e8f0;
                --border-color: #4a4a5f;
                --input-bg: #444;
                --input-focus-shadow: rgba(30, 144, 255, 0.4);
                --button-disabled-bg: #5a5a70;
                --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
                --error-color: #f5c6cb;
                --error-bg: #58282d;
                --success-color: #c3e6cb;
                --success-bg: #224029;
                --warning-color: #ffeeba;
                --warning-bg: #66512c;
                --note-color: #a2f58d;
                --note-bg: #2a5028;
                --toast-bg: #eaec6e;
                --toast-color: #1e1e2f;
            }

            /* --- 基礎 & 佈局樣式 --- */
            body {
                font-family: Arial, sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue";
                margin: 0;
                padding: 2rem;
                background-color: var(--bg-color);
                color: var(--text-color);
                line-height: 1.6;
                display: flex;
                flex-direction: column;
                align-items: center;
                min-height: 100vh;
                box-sizing: border-box;
                transition: background-color 0.3s, color 0.3s;
            }

            .container {
                background-color: var(--container-bg);
                padding: 2rem;
                border-radius: 8px;
                box-shadow: var(--box-shadow);
                width: 100%;
                max-width: 80%;
                margin-bottom: 2rem;
                border: 1px solid var(--border-color);
                transition: background-color 0.3s, border-color 0.3s;
            }

            h1,
            h2,
            h3 {
                margin-top: 0;
            }
            h1 {
                text-align: center;
                margin-bottom: 1.5rem;
            }
            section,
            .input-group {
                margin-bottom: 1.5rem;
                padding-top: 1rem;
            }
            label,
            .label-text {
                font-weight: 600;
                display: block;
                margin-bottom: 0.5rem;
            }
            hr {
                border: none;
                border-top: 1px solid var(--border-color);
                margin: 2rem 0;
            }

            /* --- 組件：按鈕 (優化) --- */
            .button-group {
                display: flex;
                flex-wrap: wrap;
                gap: 1rem;
            }
            button {
                /* 基礎按鈕樣式 */
                padding: 0.6rem 1rem;
                color: white; /* 預設文字顏色，特定類型按鈕可覆蓋 */
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1.1em;
                font-weight: 600;
                transition: background-color 0.3s, transform 0.1s, color 0.3s, border-color 0.3s;
            }
            button:hover:not(:disabled) {
                transform: translateY(-1px);
            }
            button:disabled {
                background-color: var(--button-disabled-bg);
                cursor: not-allowed;
                opacity: 0.7;
            }

            /* 預設 (Primary) 按鈕 */
            button:not([data-type]) {
                /* 如果沒有 data-type，則視為 primary */
                background-color: var(--primary-color);
            }
            button:not([data-type]):hover:not(:disabled) {
                background-color: var(--primary-hover-color);
            }

            /* 次要 (Secondary) 按鈕 */
            button[data-type="secondary"] {
                background-color: var(--secondary-color);
            }
            button[data-type="secondary"]:hover:not(:disabled) {
                background-color: var(--secondary-hover-color);
            }

            /* 危險 (Danger) 按鈕 */
            button[data-type="danger"] {
                background-color: var(--danger-color);
            }
            button[data-type="danger"]:hover:not(:disabled) {
                background-color: var(--danger-hover-color);
            }

            /* 成功 (Success) 按鈕 */
            button[data-type="success"] {
                background-color: var(--success-btn-color);
            }
            button[data-type="success"]:hover:not(:disabled) {
                background-color: var(--success-btn-hover-color);
            }

            /* 警告 (Warning) 按鈕 - 用於執行單元測試按鈕 */
            button[data-type="warning"] {
                background-color: var(--warning-btn-bg-color);
                color: var(--warning-btn-text-color);
            }
            button[data-type="warning"]:hover:not(:disabled) {
                background-color: var(--warning-btn-hover-bg-color);
            }

            /* 主執行按鈕的特定大小和邊距 */
            #btnExecute {
                width: 100%;
                padding: 0.8rem 1.5rem;
                font-size: 1.2em;
                margin: 1rem 0;
            }
            /* JavaScript 將會動態改變 #btnExecute 的 data-type */

            /* --- 組件：表單輸入 --- */
            input[type="text"],
            input[type="file"],
            textarea {
                width: 100%;
                padding: 0.75rem;
                border: 1px solid var(--border-color);
                border-radius: 5px;
                box-sizing: border-box;
                font-size: 1.2em;
                background-color: var(--input-bg);
                color: var(--text-color);
                transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s, color 0.3s;
            }
            input[type="text"]:focus,
            input[type="file"]:focus,
            textarea:focus {
                outline: none;
                border-color: var(--primary-color);
                box-shadow: 0 0 0 0.2rem var(--input-focus-shadow);
            }
            textarea {
                min-height: 120px;
                resize: vertical;
            }

            /* --- 組件：選項/頁籤組 --- */
            .option-group {
                display: flex;
                flex-wrap: wrap;
                gap: 1rem;
            }
            .option {
                padding: 0.6rem 1rem;
                border: 1px solid var(--border-color);
                border-radius: 5px;
                cursor: pointer;
                user-select: none;
                transition: background-color 0.3s, border-color 0.3s, color 0.3s;
                font-size: 1.1em;
            }
            .option.selected {
                background-color: var(--primary-color);
                color: white;
                border-color: var(--primary-color);
            }
            .option:not(.selected):hover {
                background-color: var(--input-bg);
                border-color: var(--primary-color);
            }
            .option.disabled {
                pointer-events: none;
                opacity: 0.5;
                cursor: not-allowed;
            }

            /* --- 組件：訊息與提示 (優化) --- */
            /* 基礎訊息框 */
            .status-message {
                padding: 1rem;
                border-radius: 5px;
                border: 1px solid transparent;
                display: none; /* 由 JS 控制 active class */
                margin-top: 1rem; /* 統一添加 margin-top */
            }
            .status-message.active {
                display: block;
            }
            /* 成功訊息 */
            .status-success {
                background-color: var(--success-bg);
                color: var(--success-color);
                border-color: var(--success-color); /* 或 var(--success-bg) 讓邊框不明顯 */
            }
            /* 錯誤訊息 */
            .status-error {
                background-color: var(--error-bg);
                color: var(--error-color);
                border-color: var(--error-color); /* 或 var(--error-bg) */
            }
            /* 表單內嵌的錯誤訊息 */
            .error-message {
                color: var(--error-color);
                font-size: 0.9em;
                min-height: 1.2em;
                display: block;
                margin-top: 0.25rem;
            }

            /* 通用提示框 (alert) */
            .alert {
                font-size: 0.9em;
                padding: 1rem;
                border-radius: 5px;
                margin: 1rem 0;
                border: 1px solid;
            }
            .alert-note {
                background-color: var(--note-bg);
                color: var(--note-color);
                border-color: var(--note-color); /* 或 var(--note-bg) */
            }
            .alert-danger {
                /* 用於 .security-note */
                background-color: var(--error-bg);
                color: var(--error-color);
                border-color: var(--error-color); /* 或 var(--error-bg) */
            }
            .alert-warning {
                /* 用於 .best-practices, #testResults */
                background-color: var(--warning-bg);
                color: var(--warning-color);
                border-color: var(--warning-color); /* 或 var(--warning-bg) */
            }

            details > summary {
                cursor: pointer;
                font-weight: bold;
                padding: 0.5rem 0;
            }
            /* .best-practices 是 <details> 元素，其內部 ul/li 樣式 */
            .alert-warning ul {
                margin: 0.5rem 0 0.25rem 1.25rem;
                padding: 0;
            }
            .alert-warning li {
                margin-bottom: 0.5rem;
            }

            .alert-warning .pass {
                color: var(--success-color);
            }
            .alert-warning .fail {
                color: var(--error-color);
                font-weight: bold;
            }

            /* --- 組件：頁尾 --- */
            footer {
                text-align: center;
                margin-top: auto; /* 將頁尾推到底部 */
                padding-top: 1rem;
                font-size: 0.9em;
                color: var(--secondary-color);
            }
            #themeToggleBtn {
                background: none;
                border: 1px solid var(--border-color);
                color: var(--text-color);
                padding: 0.25rem;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1.2em;
                margin-left: 0.5rem;
                vertical-align: middle;
                transition: background-color 0.3s, color 0.3s, border-color 0.3s;
            }
            #themeToggleBtn:hover {
                background-color: var(--border-color);
            }

            /* --- 響應式設計 --- */
            @media (max-width: 768px) {
                body {
                    padding: 1rem;
                }
                .container {
                    padding: 1.5rem;
                    max-width: 95%;
                }
                /* 可以在此處為小螢幕調整按鈕、輸入框等的大小或排列 */
                .button-group {
                    /* gap: 0.5rem; /* 小螢幕時縮小間距 */
                }
                button {
                    /* font-size: 0.85em; /* 小螢幕時略微縮小字體 */
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>進階 AES 加解密工具</h1>

            <details class="alert alert-warning">
                <summary>🔐 <strong>安全性與最佳實踐（點擊展開）</strong></summary>
                <ul>
                    <li>
                        <strong>金鑰管理：</strong>
                        <ul>
                            <li>請使用由密碼學安全隨機數產生器 (CSPRNG) 產生的金鑰。避免使用容易猜測的字串。</li>
                            <li>此工具中的金鑰是純文字，長度將依據 UTF-8 編碼後的位元組數計算。</li>
                            <li>
                                請勿在不安全的環境中儲存或傳輸您的金鑰。此工具適用於臨時操作，金鑰存在瀏覽器記憶體中。
                            </li>
                            <li>金鑰長度越長 (如 256 位元) 通常越安全。</li>
                        </ul>
                    </li>
                    <li>
                        <strong>初始向量 (IV) / Nonce：</strong>
                        <ul>
                            <li>
                                <strong>GCM/CTR 模式：</strong>IV (Nonce)
                                絕對不能重複使用於同一金鑰下的不同加密操作。重複使用會嚴重危及安全性。建議每次加密都產生新的隨機
                                IV。IV 長度通常為 12 位元組 (96 位元)，但 Web Crypto API for GCM/CTR 通常接受 16 位元組
                                (128 位元) IV 並可能在內部截斷或處理。此工具預期 UTF-8 編碼後為 16 位元組的 IV 文字。
                            </li>
                            <li>
                                <strong>CBC 模式：</strong>IV 必須是不可預測的 (隨機的)。雖然不要求唯一，但重複使用已知
                                IV 配合相同金鑰可能洩漏部分明文資訊。
                            </li>
                            <li>
                                <strong>ECB 模式：</strong>不使用
                                IV，因此不建議用於大多數情況，因其模式本身有安全性缺陷。
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>附加驗證資料 (AAD)：</strong> (僅 GCM 模式)
                        <ul>
                            <li>AAD 是不被加密但會被認證的資料。例如，訊息標頭或元數據。</li>
                            <li>解密時，若 AAD 與加密時不符，解密會失敗，確保資料完整性與真實性。</li>
                        </ul>
                    </li>
                    <li>
                        <strong>前端加密：</strong
                        >所有操作均在您的瀏覽器中進行。雖然方便，但請確保您的瀏覽器和電腦環境安全。
                    </li>
                </ul>
            </details>

            <div id="functionMode" class="option-group">
                <div id="FunctionEncrypt" class="option selected" data-value="encrypt">加密模式</div>
                <div id="FunctionDecrypt" class="option" data-value="decrypt">解密模式</div>
            </div>

            <div class="input-group">
                <label class="label-text">輸入來源</label>
                <div id="inputSource" class="option-group">
                    <div class="option selected" data-value="text">文字輸入</div>
                    <div class="option" data-value="file">檔案輸入</div>
                </div>
            </div>

            <div id="textInputGroup" class="input-group">
                <label for="text">原始文字 / 密文</label>
                <textarea id="text" rows="5" placeholder="在此輸入要加密的明文或要解密的密文（Base64/Hex）"></textarea>
                <div class="button-group" style="margin-top: 10px">
                    <button id="copyTextButton" data-type="secondary">複製</button>
                    <button id="pasteTextButton" data-type="secondary">貼上</button>
                    <button id="clearTextButton" data-type="secondary">清除</button>
                </div>
            </div>

            <div id="fileInputGroup" class="input-group" style="display: none">
                <label for="fileInput">選擇檔案</label>
                <input type="file" id="fileInput" />
                <div
                    id="fileNameDisplay"
                    class="alert alert-note"
                    style="margin-top: 10px; display: none; padding: 0.5rem 1rem"
                ></div>
            </div>

            <div class="input-group">
                <label class="label-text">加密演算法模式</label>
                <div id="encryptionMode" class="option-group">
                    <div class="option selected" data-value="GCM">GCM</div>
                    <div class="option" data-value="CTR">CTR</div>
                    <div class="option" data-value="CBC">CBC</div>
                    <div class="option" data-value="ECB">ECB</div>
                </div>
                <div class="alert alert-danger" id="ecbWarning" style="display: none">
                    <strong>注意：</strong>ECB
                    模式通常不安全，因為相同的明文塊會加密成相同的密文塊。建議僅在特殊情況下使用。
                </div>
            </div>

            <div id="paddingGroup" class="input-group" style="display: none">
                <label class="label-text">填充模式</label>
                <div id="padding" class="option-group">
                    <div class="option selected" data-value="Pkcs7">PKCS7</div>
                    <div class="option" data-value="NoPadding">NoPadding</div>
                </div>
                <div class="alert alert-note" id="noPaddingNote" style="display: none">
                    使用 NoPadding 時，CBC/ECB 模式的明文長度（UTF-8 編碼後的位元組）必須是 16 的倍數。
                </div>
            </div>

            <div class="input-group">
                <label class="label-text">金鑰長度（位元組）</label>
                <div id="keySize" class="option-group">
                    <div class="option selected" data-value="128">128</div>
                    <div class="option" data-value="192">192</div>
                    <div class="option" data-value="256">256</div>
                </div>
            </div>

            <div class="input-group">
                <label for="secretKey">金鑰 (純文字)</label>
                <input type="text" id="secretKey" placeholder="輸入金鑰文字" />
                <div class="alert alert-note">
                    金鑰文字將以 UTF-8 編碼。編碼後的「<strong>位元組長度</strong>」需符合所選金鑰長度。
                </div>
                <div id="msgKeyError" class="error-message"></div>
            </div>

            <div id="ivGroup" class="input-group">
                <label for="iv">初始向量（IV），本工具僅支援純文字</label>
                <div style="display: flex; gap: 10px; align-items: center">
                    <input type="text" id="iv" placeholder="輸入 IV 文字 (通常需 16 位元組)" style="flex-grow: 1" />
                    <button id="generateIvButton" data-type="secondary">產生隨機 IV</button>
                </div>
                <div class="alert alert-note">
                    GCM、CTR、CBC 模式中，IV 為必填。<br /><strong>重要：</strong>GCM/CTR 模式下，同一金鑰每次加密的 IV
                    必須唯一！
                </div>
                <div id="msgIVError" class="error-message"></div>
            </div>

            <div id="aadGroup" class="input-group" style="display: none">
                <label for="aad">附加驗證資料（AAD），本工具僅支援純文字</label>
                <textarea id="aad" rows="2" placeholder="輸入 AAD 文字（可選）"></textarea>
                <div class="alert alert-note">此資料不會被加密，但會影響 GCM 模式的認證標籤。</div>
                <div id="msgAadError" class="error-message"></div>
            </div>

            <div id="tagLengthGroup" class="input-group" style="display: none">
                <label class="label-text">認證標籤長度（位元組）</label>
                <div id="tagLength" class="option-group">
                    <div class="option selected" data-value="128">128</div>
                    <div class="option" data-value="120">120</div>
                    <div class="option" data-value="112">112</div>
                    <div class="option" data-value="104">104</div>
                    <div class="option" data-value="96">96</div>
                </div>
                <div class="alert alert-note">僅 GCM 模式須指定。</div>
            </div>

            <div id="inputCiphertextFormatGroup" class="input-group" style="display: none">
                <label class="label-text">輸入密文格式</label>
                <div id="inputCiphertextFormat" class="option-group">
                    <div class="option selected" data-value="base64">Base64</div>
                    <div class="option" data-value="hex">Hex</div>
                </div>
            </div>

            <div class="input-group">
                <label class="label-text">輸出格式</label>
                <div id="outputFormat" class="option-group">
                    <div id="optTextFormat" class="option" data-value="plaintext">明文</div>
                    <div id="optBase64Format" class="option selected" data-value="base64">Base64</div>
                    <div id="optHexFormat" class="option" data-value="hex">Hex</div>
                    <div id="optBinaryFileFormat" class="option" data-value="binaryfile" style="display: none">
                        二進位檔案
                    </div>
                </div>
            </div>

            <button id="btnExecute" data-type="success">加密（Encrypt）</button>
            <div id="status" class="status-message"></div>
            <div class="input-group">
                <label for="result">結果</label>
                <textarea id="result" rows="5" readonly placeholder="加解密結果將顯示於此"></textarea>
                <div class="button-group" style="margin-top: 10px">
                    <button id="copyResultButton" data-type="secondary">複製結果</button>
                    <button id="swapTextResultButton" data-type="secondary">交換輸入/輸出</button>
                    <button id="clearResultButton" data-type="secondary">清除結果</button>
                </div>
            </div>

            <hr />

            <div class="button-group" style="justify-content: center">
                <button id="resetFormButton" data-type="danger">🔁 重置所有設定</button>
                <button id="runTestsButton" data-type="warning">執行單元測試</button>
            </div>
            <div id="testResults" class="alert alert-warning" style="display: none"><h4>測試結果：</h4></div>
        </div>

        <footer>
            <p>
                &copy; <span id="currentYear"></span> Zanta's Advanced AES Tool
                <button id="themeToggleBtn" title="切換主題">🌙</button>
            </p>
        </footer>

        <script>
            // ---- Constants & Configuration ----
            const APP_NAME_SETTINGS = "aesAdvancedToolSettings";
            const UI_CONFIG = [
                { mode: "GCM", padding: 0, keySize: 1, iv: 1, tagLength: 1, aad: 1 },
                { mode: "CTR", padding: 0, keySize: 1, iv: 1, tagLength: 0, aad: 0 },
                { mode: "CBC", padding: 1, keySize: 1, iv: 1, tagLength: 0, aad: 0 },
                { mode: "ECB", padding: 1, keySize: 1, iv: 0, tagLength: 0, aad: 0 },
            ];
            const REQUIRED_IV_BYTE_LENGTH = 16;

            // ---- DOM Element Cache ----
            const DOMElements = {};

            // --- App State Management ---
            const AppState = {
                currentSettings: {},
                isProcessing: false,
                loadedFileName: null,
                loadedFileBuffer: null,
            };

            // ---- Initialization on DOMContentLoaded ----
            document.addEventListener("DOMContentLoaded", () => {
                cacheDOMElements();
                loadSettings();
                TestModule.init();
                bindEventListeners();
                UIModule.toggleUI(); // Initial UI setup based on loaded settings
                StatusModule.update("工具已就緒。", false);

                const initialTheme = localStorage.getItem("my-app-theme") || "dark";
                applyTheme(initialTheme);
            });

            function cacheDOMElements() {
                const ids = [
                    "functionMode",
                    "FunctionEncrypt",
                    "FunctionDecrypt",
                    "inputSource",
                    "textInputGroup",
                    "fileInputGroup",
                    "text",
                    "fileInput",
                    "fileNameDisplay",
                    "encryptionMode",
                    "ecbWarning",
                    "paddingGroup",
                    "padding",
                    "noPaddingNote",
                    "keySize",
                    "secretKey",
                    "msgKeyError",
                    "ivGroup",
                    "iv",
                    "generateIvButton",
                    "msgIVError",
                    "aadGroup",
                    "aad",
                    "msgAadError",
                    "tagLengthGroup",
                    "tagLength",
                    "inputCiphertextFormatGroup",
                    "inputCiphertextFormat",
                    "outputFormat",
                    "optTextFormat",
                    "optBase64Format",
                    "optHexFormat",
                    "optBinaryFileFormat",
                    "btnExecute",
                    "result",
                    "status",
                    "copyTextButton",
                    "pasteTextButton",
                    "clearTextButton",
                    "copyResultButton",
                    "clearResultButton",
                    "swapTextResultButton",
                    "resetFormButton",
                    "runTestsButton",
                    "testResults",
                    "themeToggleBtn",
                    "currentYear",
                ];
                ids.forEach((id) => (DOMElements[id] = document.getElementById(id)));
            }

            // ---- Settings (localStorage) ----
            function saveSettings() {
                try {
                    localStorage.setItem(APP_NAME_SETTINGS, JSON.stringify(AppState.currentSettings));
                } catch (e) {
                    console.warn("無法儲存設定:", e);
                }
            }

            function loadSettings() {
                const defaultSettings = {
                    functionMode: "encrypt",
                    inputSource: "text",
                    encryptionMode: "GCM",
                    padding: "Pkcs7",
                    keySize: "128",
                    tagLength: "128",
                    inputCiphertextFormat: "base64",
                    outputFormat: "base64",
                };
                AppState.currentSettings = { ...defaultSettings };
                try {
                    const saved = localStorage.getItem(APP_NAME_SETTINGS);
                    if (saved) {
                        Object.assign(AppState.currentSettings, JSON.parse(saved));
                    }
                } catch (e) {
                    console.warn("無法載入設定:", e);
                    AppState.currentSettings = { ...defaultSettings }; // Fallback to defaults
                }
                applySettingsToUI(); // Apply loaded or default settings to UI elements
            }

            function applySettingsToUI() {
                // Apply settings to all option groups
                selectOptionByValue(DOMElements.functionMode, AppState.currentSettings.functionMode);
                selectOptionByValue(DOMElements.inputSource, AppState.currentSettings.inputSource);
                selectOptionByValue(DOMElements.encryptionMode, AppState.currentSettings.encryptionMode);
                selectOptionByValue(DOMElements.padding, AppState.currentSettings.padding);
                selectOptionByValue(DOMElements.keySize, AppState.currentSettings.keySize);
                selectOptionByValue(DOMElements.tagLength, AppState.currentSettings.tagLength);
                selectOptionByValue(DOMElements.inputCiphertextFormat, AppState.currentSettings.inputCiphertextFormat);
                // Output format selection is handled by UIModule.toggleUI after this,
                // as its available options depend on other settings.
            }

            function updateCurrentSetting(groupId, value) {
                const settingKey = groupId; // Assuming groupId directly maps to AppState.currentSettings keys
                if (AppState.currentSettings.hasOwnProperty(settingKey)) {
                    AppState.currentSettings[settingKey] = value;
                    saveSettings();
                }
            }

            // ---- Theme Module ----
            function applyTheme(theme) {
                document.documentElement.setAttribute("data-theme", theme);
                DOMElements.themeToggleBtn.textContent = theme === "dark" ? "☀️" : "🌙";
                localStorage.setItem("my-app-theme", theme);
            }

            // ---- UI Module ----
            const UIModule = {
                toggleUI: function () {
                    const { functionMode, encryptionMode, inputSource, padding } = AppState.currentSettings;
                    const config = UI_CONFIG.find((c) => c.mode === encryptionMode);
                    if (!config) return;

                    DOMElements.textInputGroup.style.display = inputSource === "text" ? "block" : "none";
                    DOMElements.fileInputGroup.style.display = inputSource === "file" ? "block" : "none";
                    DOMElements.paddingGroup.style.display = config.padding ? "block" : "none";
                    DOMElements.ivGroup.style.display = config.iv ? "block" : "none";
                    DOMElements.aadGroup.style.display = config.aad ? "block" : "none";
                    DOMElements.tagLengthGroup.style.display = config.tagLength ? "block" : "none";
                    DOMElements.ecbWarning.style.display = encryptionMode === "ECB" ? "block" : "none";
                    DOMElements.noPaddingNote.style.display =
                        config.padding && padding === "NoPadding" ? "block" : "none";

                    // Update main execute button text and type (for styling)
                    const isEncrypt = functionMode === "encrypt";
                    DOMElements.btnExecute.textContent = isEncrypt ? "加密（Encrypt）" : "解密（Decrypt）";
                    DOMElements.btnExecute.dataset.type = isEncrypt ? "success" : "danger"; // Use data-type for styling

                    DOMElements.inputCiphertextFormatGroup.style.display = isEncrypt ? "none" : "block";

                    // Control visibility of output format options
                    if (inputSource === "text") {
                        DOMElements.optTextFormat.style.display = isEncrypt ? "none" : "block";
                        DOMElements.optBase64Format.style.display = "block"; // Always visible for text input
                        DOMElements.optHexFormat.style.display = "block"; // Always visible for text input
                        DOMElements.optBinaryFileFormat.style.display = "none";
                    } else {
                        // inputSource === "file"
                        DOMElements.optTextFormat.style.display = "block"; // Can decrypt file to text
                        DOMElements.optBase64Format.style.display = "block";
                        DOMElements.optHexFormat.style.display = "block";
                        DOMElements.optBinaryFileFormat.style.display = "block";
                    }

                    // Ensure a valid output format is selected if the current one becomes hidden
                    const currentOutputOptionEl = DOMElements.outputFormat.querySelector(
                        `.option[data-value='${AppState.currentSettings.outputFormat}']`
                    );
                    if (!currentOutputOptionEl || currentOutputOptionEl.style.display === "none") {
                        let newDefaultOutputFormat;
                        if (isEncrypt) {
                            newDefaultOutputFormat = inputSource === "text" ? "base64" : "binaryfile";
                        } else {
                            // Decrypt
                            newDefaultOutputFormat = inputSource === "text" ? "plaintext" : "binaryfile";
                        }
                        // Check if this new default is visible, otherwise pick the first visible one
                        const newDefaultIsVisibleEl = DOMElements.outputFormat.querySelector(
                            `.option[data-value='${newDefaultOutputFormat}']`
                        );
                        if (newDefaultIsVisibleEl && newDefaultIsVisibleEl.style.display !== "none") {
                            AppState.currentSettings.outputFormat = newDefaultOutputFormat;
                        } else {
                            const firstVisibleOutputOption = DOMElements.outputFormat.querySelector(
                                ".option:not([style*='display: none'])"
                            );
                            if (firstVisibleOutputOption) {
                                AppState.currentSettings.outputFormat = firstVisibleOutputOption.dataset.value;
                            }
                        }
                        saveSettings(); // Save if changed
                    }
                    selectOptionByValue(DOMElements.outputFormat, AppState.currentSettings.outputFormat);

                    DOMElements.text.placeholder = isEncrypt
                        ? "在此輸入要加密的明文"
                        : "在此輸入要解密的密文（Base64/Hex）";
                },

                resetForm: function () {
                    const fieldsToClear = [
                        DOMElements.text,
                        DOMElements.secretKey,
                        DOMElements.iv,
                        DOMElements.aad,
                        DOMElements.result,
                    ];
                    fieldsToClear.forEach((el) => (el.value = ""));
                    DOMElements.fileInput.value = ""; // Clear file input
                    AppState.loadedFileName = null;
                    AppState.loadedFileBuffer = null;
                    DOMElements.fileNameDisplay.textContent = "";
                    DOMElements.fileNameDisplay.style.display = "none";
                    [DOMElements.msgKeyError, DOMElements.msgIVError, DOMElements.msgAadError].forEach(
                        (el) => (el.textContent = "")
                    );
                    StatusModule.clear();
                    loadSettings(); // Reload default/saved settings
                    UIModule.toggleUI(); // Re-apply UI based on reset settings
                },

                handleFileUpload: function (event) {
                    const file = event.target.files[0];
                    if (!file) {
                        AppState.loadedFileName = null;
                        AppState.loadedFileBuffer = null;
                        DOMElements.fileNameDisplay.style.display = "none";
                        return;
                    }
                    AppState.loadedFileName = file.name;
                    DOMElements.fileNameDisplay.textContent = `已選擇檔案: ${file.name} (${(file.size / 1024).toFixed(
                        2
                    )} KB)`;
                    DOMElements.fileNameDisplay.style.display = "block";

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        AppState.loadedFileBuffer = e.target.result;
                        // If input source is file, ensure UI reflects this (e.g. output options)
                        if (AppState.currentSettings.inputSource === "file") {
                            // UIModule.toggleUI(); // Potentially re-toggle if output options depend on file load state.
                            // Usually, changing inputSource itself triggers toggleUI.
                        }
                    };
                    reader.onerror = () => {
                        StatusModule.update("讀取檔案失敗。", true);
                    };
                    reader.readAsArrayBuffer(file);
                },
            };

            // ---- EncodingUtils, CryptoModule, ValidationModule, StatusModule, HelperUtils, TestModule ----
            // (保持原有邏輯，此處為簡化省略，實際應包含完整實作)

            const EncodingUtils = {
                arrayBufferToBase64: (buf) => btoa(String.fromCharCode.apply(null, new Uint8Array(buf))),
                base64ToArrayBuffer: (b64) => Uint8Array.from(atob(b64), (c) => c.charCodeAt(0)).buffer,
                arrayBufferToHex: (buf) =>
                    Array.from(new Uint8Array(buf))
                        .map((b) => b.toString(16).padStart(2, "0"))
                        .join(""),
                hexToArrayBuffer: (hex) => {
                    if (!/^[0-9a-fA-F]+$/.test(hex) || hex.length % 2 !== 0) throw new Error("無效的 Hex 字串格式。");
                    const bytes = new Uint8Array(hex.length / 2);
                    for (let i = 0; i < hex.length; i += 2) bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
                    return bytes.buffer;
                },
                stringToUtf8ArrayBuffer: (str) => new TextEncoder().encode(str).buffer,
                utf8ArrayBufferToString: (buf) => new TextDecoder().decode(buf),
                generateRandomIVText: () => {
                    const randomBytes = new Uint8Array(REQUIRED_IV_BYTE_LENGTH);
                    window.crypto.getRandomValues(randomBytes);
                    // Generate a string that is likely to be valid UTF-8 and of the correct byte length
                    // Using a restricted character set for simplicity, actual byte length depends on chars
                    const PURE_ASCII = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    return Array.from(randomBytes)
                        .map((byte) => PURE_ASCII[byte % PURE_ASCII.length])
                        .join("");
                },
            };

            const CryptoModule = {
                processData: async function () {
                    if (AppState.isProcessing) return;
                    AppState.isProcessing = true;
                    DOMElements.btnExecute.disabled = true;
                    StatusModule.clear();

                    if (!ValidationModule.validateAllInputs()) {
                        AppState.isProcessing = false;
                        DOMElements.btnExecute.disabled = false;
                        return;
                    }

                    const {
                        functionMode,
                        encryptionMode,
                        outputFormat,
                        inputSource,
                        inputCiphertextFormat,
                        padding,
                        tagLength,
                    } = AppState.currentSettings;
                    const { secretKey, iv, aad, text } = DOMElements;
                    let dataToProcess = inputSource === "text" ? text.value : AppState.loadedFileBuffer;

                    if (
                        (inputSource === "text" && !dataToProcess && functionMode === "encrypt") ||
                        (inputSource === "file" && !dataToProcess)
                    ) {
                        if (functionMode === "encrypt" || (functionMode === "decrypt" && inputSource === "file")) {
                            // Check if input is actually required
                            StatusModule.update("錯誤：沒有輸入內容。", true);
                            AppState.isProcessing = false;
                            DOMElements.btnExecute.disabled = false;
                            return;
                        }
                    }

                    try {
                        let resultData =
                            functionMode === "encrypt"
                                ? await this.performEncryption(
                                      encryptionMode,
                                      dataToProcess,
                                      secretKey.value,
                                      iv.value,
                                      aad.value,
                                      tagLength,
                                      padding
                                  )
                                : await this.performDecryption(
                                      encryptionMode,
                                      dataToProcess,
                                      secretKey.value,
                                      iv.value,
                                      aad.value,
                                      tagLength,
                                      padding,
                                      inputCiphertextFormat
                                  );

                        if (outputFormat === "binaryfile") {
                            const fname = HelperUtils.generateOutputFileName(AppState.loadedFileName, functionMode);
                            HelperUtils.downloadArrayBuffer(resultData, fname);
                            DOMElements.result.value = `檔案 "${fname}" 已開始下載。`;
                        } else {
                            DOMElements.result.value =
                                outputFormat === "plaintext"
                                    ? EncodingUtils.utf8ArrayBufferToString(resultData)
                                    : outputFormat === "base64"
                                    ? EncodingUtils.arrayBufferToBase64(resultData)
                                    : EncodingUtils.arrayBufferToHex(resultData);
                        }
                        if (!StatusModule.hasWarning())
                            StatusModule.update(`${functionMode === "encrypt" ? "加密" : "解密"}成功`, false);
                    } catch (error) {
                        console.error("處理錯誤:", error);
                        StatusModule.update(`錯誤: ${error.message || error}`, true);
                        if (
                            error.message?.toLowerCase().includes("decryption failed") ||
                            error.name === "OperationError" ||
                            error.message?.toLowerCase().includes("bad decrypt")
                        ) {
                            StatusModule.update(
                                " (GCM/CTR 模式下，這通常表示金鑰、IV、密文或 AAD 不匹配，或密文已被篡改。CBC/ECB模式下，可能是金鑰/IV錯誤或填充問題)",
                                true,
                                "append"
                            );
                        }
                    } finally {
                        AppState.isProcessing = false;
                        DOMElements.btnExecute.disabled = false;
                    }
                },
                performEncryption: async function (mode, plainData, key, iv, aad, tag, pad) {
                    const apiMode = `AES-${mode}`;
                    const plainBuf =
                        typeof plainData === "string" ? EncodingUtils.stringToUtf8ArrayBuffer(plainData) : plainData;

                    if (mode === "GCM" || mode === "CTR") {
                        // Web Crypto API
                        const cryptoKey = await crypto.subtle.importKey(
                            "raw",
                            EncodingUtils.stringToUtf8ArrayBuffer(key),
                            { name: apiMode },
                            false,
                            ["encrypt"]
                        );
                        const ivBytes = EncodingUtils.stringToUtf8ArrayBuffer(iv);
                        const alg = { name: apiMode, iv: ivBytes };
                        if (mode === "GCM") {
                            alg.tagLength = parseInt(tag);
                            if (aad) alg.additionalData = EncodingUtils.stringToUtf8ArrayBuffer(aad);
                        }
                        if (mode === "CTR") {
                            // CTR uses 'counter' which is the IV, and 'length' for counter block size (usually 64 or 128)
                            alg.counter = ivBytes; // The IV is the counter block
                            alg.length = 64; // Common counter length, can be 128. Ensure this matches expectations.
                        }
                        return await crypto.subtle.encrypt(alg, cryptoKey, plainBuf);
                    } else {
                        // CryptoJS for CBC, ECB
                        const keyC = CryptoJS.enc.Utf8.parse(key);
                        const ivC = mode === "CBC" && iv ? CryptoJS.enc.Utf8.parse(iv) : undefined; // IV only for CBC
                        const dataC =
                            typeof plainData === "string"
                                ? CryptoJS.enc.Utf8.parse(plainData)
                                : CryptoJS.lib.WordArray.create(plainData); // Handle ArrayBuffer

                        const cryptoJSMode = mode === "CBC" ? CryptoJS.mode.CBC : CryptoJS.mode.ECB;
                        const cryptoJSPadding = pad === "Pkcs7" ? CryptoJS.pad.Pkcs7 : CryptoJS.pad.NoPadding;

                        const encrypted = CryptoJS.AES.encrypt(dataC, keyC, {
                            mode: cryptoJSMode,
                            padding: cryptoJSPadding,
                            iv: ivC,
                        });
                        return EncodingUtils.hexToArrayBuffer(encrypted.ciphertext.toString(CryptoJS.enc.Hex));
                    }
                },
                performDecryption: async function (mode, cipherData, key, iv, aad, tag, pad, inputFormat) {
                    const apiMode = `AES-${mode}`;
                    const cipherBuf =
                        typeof cipherData === "string"
                            ? inputFormat === "base64"
                                ? EncodingUtils.base64ToArrayBuffer(cipherData)
                                : EncodingUtils.hexToArrayBuffer(cipherData)
                            : cipherData;

                    if (mode === "GCM" || mode === "CTR") {
                        // Web Crypto API
                        const cryptoKey = await crypto.subtle.importKey(
                            "raw",
                            EncodingUtils.stringToUtf8ArrayBuffer(key),
                            { name: apiMode },
                            false,
                            ["decrypt"]
                        );
                        const ivBytes = EncodingUtils.stringToUtf8ArrayBuffer(iv);
                        const alg = { name: apiMode, iv: ivBytes };
                        if (mode === "GCM") {
                            alg.tagLength = parseInt(tag);
                            if (aad) alg.additionalData = EncodingUtils.stringToUtf8ArrayBuffer(aad);
                        }
                        if (mode === "CTR") {
                            alg.counter = ivBytes;
                            alg.length = 64;
                        }
                        return await crypto.subtle.decrypt(alg, cryptoKey, cipherBuf);
                    } else {
                        // CryptoJS for CBC, ECB
                        const keyC = CryptoJS.enc.Utf8.parse(key);
                        const ivC = mode === "CBC" && iv ? CryptoJS.enc.Utf8.parse(iv) : undefined;
                        // CryptoJS expects ciphertext as a WordArray or Base64 string for its specific format object.
                        // We have ArrayBuffer, so convert to Base64 string for CryptoJS.AES.decrypt's {ciphertext: ...} object.
                        const cipherTextForCryptoJS = CryptoJS.enc.Base64.parse(
                            EncodingUtils.arrayBufferToBase64(cipherBuf)
                        );

                        const cryptoJSMode = mode === "CBC" ? CryptoJS.mode.CBC : CryptoJS.mode.ECB;
                        const cryptoJSPadding = pad === "Pkcs7" ? CryptoJS.pad.Pkcs7 : CryptoJS.pad.NoPadding;

                        const decrypted = CryptoJS.AES.decrypt({ ciphertext: cipherTextForCryptoJS }, keyC, {
                            mode: cryptoJSMode,
                            padding: cryptoJSPadding,
                            iv: ivC,
                        });
                        // Check if decryption produced any output (CryptoJS returns empty WordArray on failure)
                        if (decrypted.sigBytes <= 0 && cipherBuf.byteLength > 0) {
                            // sigBytes is number of significant bytes
                            throw new Error("解密失敗。請檢查金鑰、IV、密文格式或填充模式。");
                        }
                        return EncodingUtils.hexToArrayBuffer(decrypted.toString(CryptoJS.enc.Hex));
                    }
                },
            };

            const ValidationModule = {
                validateAllInputs: function () {
                    DOMElements.msgKeyError.textContent = "";
                    DOMElements.msgIVError.textContent = "";
                    DOMElements.msgAadError.textContent = ""; // Assuming you might add AAD validation
                    let isValid = true;

                    const keyErr = this.validateSecretKey(
                        DOMElements.secretKey.value,
                        AppState.currentSettings.keySize
                    );
                    if (keyErr) {
                        StatusModule.displayError(keyErr, DOMElements.msgKeyError);
                        isValid = false;
                    }

                    const config = UI_CONFIG.find((c) => c.mode === AppState.currentSettings.encryptionMode);
                    if (config && config.iv) {
                        // Only validate IV if current mode requires it
                        const ivErr = this.validateInitialVector(DOMElements.iv.value);
                        if (ivErr) {
                            StatusModule.displayError(ivErr, DOMElements.msgIVError);
                            isValid = false;
                        }
                    }
                    // Add more validations if needed (e.g., AAD, input text format for decrypt)
                    return isValid;
                },
                validateSecretKey: (key, size) => {
                    if (!key) return "* 金鑰為必填。";
                    const len = EncodingUtils.stringToUtf8ArrayBuffer(key).byteLength; // Use Utf8ArrayBuffer for byte length
                    const req = parseInt(size) / 8;
                    return len !== req ? `* 金鑰 UTF-8 編碼後為 ${len} 位元組，應為 ${req} 位元組。` : null;
                },
                validateInitialVector: (iv) => {
                    const mode = AppState.currentSettings.encryptionMode;
                    if (mode === "ECB") return null; // ECB does not use IV
                    if (!iv) return "* IV 為必填 (GCM/CTR/CBC 模式)。";
                    const len = EncodingUtils.stringToUtf8ArrayBuffer(iv).byteLength;
                    // GCM/CTR often recommend 12 bytes (96 bits) for IV, but 16 bytes (128 bits) is also common.
                    // Web Crypto API for CTR uses the IV as the counter block, which is typically 16 bytes.
                    // For simplicity and compatibility with CryptoJS's 16-byte block operations, we'll stick to 16 bytes.
                    return len !== REQUIRED_IV_BYTE_LENGTH
                        ? `* IV UTF-8 編碼後為 ${len} 位元組，應為 ${REQUIRED_IV_BYTE_LENGTH} 位元組。`
                        : null;
                },
            };

            const StatusModule = {
                update: (msg, isErr, mode = "normal") => {
                    // mode can be "normal" or "append"
                    const el = DOMElements.status;
                    if (mode === "append" && el.innerHTML) {
                        // Append only if there's existing content
                        el.innerHTML += `<br>${msg}`;
                    } else {
                        el.textContent = msg;
                    }
                    if (msg) {
                        el.className = `status-message ${isErr ? "status-error" : "status-success"} active`;
                    } else {
                        el.className = "status-message"; // Hide if no message
                    }
                },
                clear: () => StatusModule.update("", false),
                displayError: (msg, el) => {
                    // For inline error messages
                    if (el) el.textContent = msg;
                    // Optionally, also update the main status message if it's a validation summary
                    StatusModule.update("輸入驗證失敗。請檢查下方提示。", true);
                },
                hasWarning: () => DOMElements.status.textContent.includes("警告"),
            };

            const HelperUtils = {
                copyToClipboard: (elementId) => {
                    const el = DOMElements[elementId];
                    if (!el || !el.value) {
                        StatusModule.update("沒有內容可複製。", true);
                        return;
                    }
                    navigator.clipboard.writeText(el.value).then(
                        () => StatusModule.update("已複製到剪貼簿。", false),
                        () => StatusModule.update("複製失敗。請檢查瀏覽器權限或手動複製。", true)
                    );
                },
                pasteFromClipboard: async (elementId) => {
                    try {
                        const textToPaste = await navigator.clipboard.readText();
                        DOMElements[elementId].value = textToPaste;
                        StatusModule.update("已貼上內容。", false);
                    } catch (e) {
                        StatusModule.update("貼上失敗。請檢查瀏覽器權限或手動貼上。", true);
                    }
                },
                clearValue: (elementId) => {
                    DOMElements[elementId].value = "";
                },
                swapTextAndResult: () => {
                    [DOMElements.text.value, DOMElements.result.value] = [
                        DOMElements.result.value,
                        DOMElements.text.value,
                    ];
                    StatusModule.update("輸入與結果已交換。", false);
                },
                downloadArrayBuffer: (buf, fname) => {
                    const a = document.createElement("a");
                    a.href = URL.createObjectURL(new Blob([buf]));
                    a.download = fname || "download.bin";
                    document.body.appendChild(a); // Required for Firefox
                    a.click();
                    document.body.removeChild(a); // Clean up
                    URL.revokeObjectURL(a.href);
                },
                generateOutputFileName: (originalName, operation) => {
                    const prefix = operation === "encrypt" ? "encrypted_" : "decrypted_";
                    const baseName = originalName ? originalName.replace(/^(encrypted_|decrypted_)/i, "") : "output";
                    const ext = originalName ? originalName.substring(originalName.lastIndexOf(".")) : ".bin";
                    return `${prefix}${baseName.substring(0, baseName.lastIndexOf(ext)) || baseName}${ext}`;
                },
            };

            const TestModule = {
                testResultsContainer: null,
                tests: [],
                init: function () {
                    this.testResultsContainer = DOMElements.testResults;
                    this.tests = []; // Clear previous tests if any
                    // Test 1: EncodingUtils Base64
                    this.addTest("EncodingUtils Base64 (純ASCII)", async () => {
                        const original = "Hello World!";
                        const base64 = EncodingUtils.arrayBufferToBase64(
                            EncodingUtils.stringToUtf8ArrayBuffer(original)
                        );
                        const decoded = EncodingUtils.utf8ArrayBufferToString(
                            EncodingUtils.base64ToArrayBuffer(base64)
                        );
                        this.assertEqual(decoded, original, "Base64 純ASCII 編解碼不匹配");
                    });
                    this.addTest("EncodingUtils Base64 (中文)", async () => {
                        const original = "你好，世界！";
                        const base64 = EncodingUtils.arrayBufferToBase64(
                            EncodingUtils.stringToUtf8ArrayBuffer(original)
                        );
                        const decoded = EncodingUtils.utf8ArrayBufferToString(
                            EncodingUtils.base64ToArrayBuffer(base64)
                        );
                        this.assertEqual(decoded, original, "Base64 中文編解碼不匹配");
                    });

                    // Test 2: EncodingUtils Hex
                    this.addTest("EncodingUtils Hex (純ASCII)", async () => {
                        const original = "Hello Mars!";
                        const hex = EncodingUtils.arrayBufferToHex(EncodingUtils.stringToUtf8ArrayBuffer(original));
                        const decoded = EncodingUtils.utf8ArrayBufferToString(EncodingUtils.hexToArrayBuffer(hex));
                        this.assertEqual(decoded, original, "Hex 純ASCII 編解碼不匹配");
                    });
                    this.addTest("EncodingUtils Hex (中文)", async () => {
                        const original = "你好火星！";
                        const hex = EncodingUtils.arrayBufferToHex(EncodingUtils.stringToUtf8ArrayBuffer(original));
                        const decoded = EncodingUtils.utf8ArrayBufferToString(EncodingUtils.hexToArrayBuffer(hex));
                        this.assertEqual(decoded, original, "Hex 中文編解碼不匹配");
                    });

                    // Test 3: CryptoModule GCM Encrypt/Decrypt
                    this.addTest("CryptoModule GCM (WebCrypto)", async () => {
                        const p = "GCM test message!",
                            k = "mygcmtestkey1234",
                            i = "mygcmivtext12345",
                            a = "mygcmAADdata123"; // 16, 16, 16 bytes for key, iv, aad if UTF8
                        const enc = await CryptoModule.performEncryption("GCM", p, k, i, a, "128", "NoPadding"); // NoPadding is implicit for GCM
                        this.assert(enc && enc.byteLength > 0, "GCM 加密未產生輸出");
                        const dec = await CryptoModule.performDecryption("GCM", enc, k, i, a, "128", "NoPadding", null);
                        this.assertEqual(EncodingUtils.utf8ArrayBufferToString(dec), p, "GCM 解密不匹配");
                    });

                    // Test 4: CryptoModule CBC-PKCS7 Encrypt/Decrypt (CryptoJS)
                    this.addTest("CryptoModule CBC-PKCS7 (CryptoJS)", async () => {
                        const p = "CBC test with PKCS7 padding.",
                            k = "mycbckeyis16byte",
                            i = "mycbcivtextis16b"; // 16, 16 bytes
                        const enc = await CryptoModule.performEncryption("CBC", p, k, i, "", "0", "Pkcs7");
                        this.assert(enc && enc.byteLength > 0, "CBC-PKCS7 加密失敗");
                        const dec = await CryptoModule.performDecryption("CBC", enc, k, i, "", "0", "Pkcs7", null);
                        this.assertEqual(EncodingUtils.utf8ArrayBufferToString(dec), p, "CBC-PKCS7 解密不匹配");
                    });

                    // Test 5: CryptoModule ECB-NoPadding Encrypt/Decrypt (CryptoJS) - plaintext must be multiple of 16 bytes
                    this.addTest("CryptoModule ECB-NoPadding (CryptoJS)", async () => {
                        const p = "ECBNoPadding1234"; // 16 bytes
                        const k = "anotherkey16byte"; // 16 bytes
                        const enc = await CryptoModule.performEncryption("ECB", p, k, "", "", "0", "NoPadding");
                        this.assert(enc && enc.byteLength > 0, "ECB-NoPadding 加密失敗");
                        const dec = await CryptoModule.performDecryption("ECB", enc, k, "", "", "0", "NoPadding", null);
                        this.assertEqual(EncodingUtils.utf8ArrayBufferToString(dec), p, "ECB-NoPadding 解密不匹配");
                    });
                    // Test 6: CTR Mode (WebCrypto)
                    this.addTest("CryptoModule CTR (WebCrypto)", async () => {
                        const p = "CTR test message here!",
                            k = "myctrtestkey1234",
                            i = "myctrivtext12345"; // Key & IV 16 bytes
                        const enc = await CryptoModule.performEncryption("CTR", p, k, i, null, "0", "NoPadding"); // AAD, tag, padding not used by CTR
                        this.assert(enc && enc.byteLength > 0, "CTR 加密未產生輸出");
                        const dec = await CryptoModule.performDecryption(
                            "CTR",
                            enc,
                            k,
                            i,
                            null,
                            "0",
                            "NoPadding",
                            null
                        );
                        this.assertEqual(EncodingUtils.utf8ArrayBufferToString(dec), p, "CTR 解密不匹配");
                    });
                },
                addTest: function (name, testFn) {
                    this.tests.push({ name, testFn });
                },
                runAllTests: async function () {
                    if (!this.testResultsContainer) {
                        // Ensure init has run
                        console.error("TestModule not initialized. Call TestModule.init() first.");
                        DOMElements.testResults.innerHTML = "<h4>測試結果:</h4><p class='fail'>測試模組未初始化。</p>";
                        DOMElements.testResults.style.display = "block";
                        return;
                    }
                    if (!TestModule.tests || TestModule.tests.length === 0) {
                        // Re-init if tests array is empty
                        TestModule.init();
                        if (!TestModule.tests || TestModule.tests.length === 0) {
                            StatusModule.update("錯誤：沒有可執行的測試。", true);
                            this.testResultsContainer.innerHTML = "<h4>測試結果:</h4><p>沒有可執行的測試。</p>";
                            this.testResultsContainer.style.display = "block";
                            return;
                        }
                    }

                    this.testResultsContainer.innerHTML = "<h4>測試結果:</h4>";
                    this.testResultsContainer.style.display = "block";
                    StatusModule.update("正在執行測試...", false);
                    let passes = 0,
                        failures = 0;

                    for (const test of this.tests) {
                        const resultP = document.createElement("p");
                        try {
                            await test.testFn();
                            resultP.innerHTML = `PASS: ${test.name}`;
                            resultP.className = "pass";
                            passes++;
                        } catch (e) {
                            resultP.innerHTML = `FAIL: ${
                                test.name
                            } <br/>&nbsp;&nbsp;<span style="font-size:0.9em; color: var(--error-color);">訊息: ${
                                e.message || e
                            }</span>`;
                            resultP.className = "fail";
                            failures++;
                            console.error(`Test failed: ${test.name}`, e);
                        }
                        this.testResultsContainer.appendChild(resultP);
                    }
                    const summaryP = document.createElement("p");
                    summaryP.innerHTML = `<strong>總結: ${passes} 通過, ${failures} 失敗.</strong>`;
                    this.testResultsContainer.appendChild(summaryP);
                    StatusModule.update(failures > 0 ? "部分測試失敗。" : "所有測試通過。", failures > 0);
                },
                assert: function (condition, message) {
                    if (!condition) throw new Error(message || "Assertion failed");
                },
                assertEqual: function (actual, expected, message) {
                    if (actual !== expected) throw new Error(message || `預期 "${expected}" 但得到 "${actual}"`);
                },
            };

            // ---- Event Binding ----
            function bindEventListeners() {
                DOMElements.currentYear.textContent = new Date().getFullYear();
                DOMElements.themeToggleBtn.addEventListener("click", () => {
                    const newTheme = document.documentElement.getAttribute("data-theme") === "dark" ? "light" : "dark";
                    applyTheme(newTheme);
                });

                const optionGroupIds = [
                    "functionMode",
                    "inputSource",
                    "encryptionMode",
                    "padding",
                    "keySize",
                    "tagLength",
                    "inputCiphertextFormat",
                    "outputFormat",
                ];
                optionGroupIds.forEach((id) => DOMElements[id]?.addEventListener("click", handleOptionGroupClick));

                DOMElements.btnExecute.addEventListener("click", CryptoModule.processData.bind(CryptoModule));
                DOMElements.resetFormButton.addEventListener("click", UIModule.resetForm);
                DOMElements.copyTextButton.addEventListener("click", () => HelperUtils.copyToClipboard("text"));
                DOMElements.pasteTextButton.addEventListener("click", () => HelperUtils.pasteFromClipboard("text"));
                DOMElements.clearTextButton.addEventListener("click", () => HelperUtils.clearValue("text"));
                DOMElements.copyResultButton.addEventListener("click", () => HelperUtils.copyToClipboard("result"));
                DOMElements.clearResultButton.addEventListener("click", () => HelperUtils.clearValue("result"));
                DOMElements.swapTextResultButton.addEventListener("click", HelperUtils.swapTextAndResult);
                DOMElements.generateIvButton.addEventListener("click", () => {
                    DOMElements.iv.value = EncodingUtils.generateRandomIVText();
                    ValidationModule.validateInitialVector(DOMElements.iv.value); // Optionally re-validate
                });
                DOMElements.fileInput.addEventListener("change", UIModule.handleFileUpload);
                DOMElements.runTestsButton.addEventListener("click", TestModule.runAllTests.bind(TestModule));

                // Live validation for key and IV
                DOMElements.secretKey.addEventListener("input", () => {
                    const err = ValidationModule.validateSecretKey(
                        DOMElements.secretKey.value,
                        AppState.currentSettings.keySize
                    );
                    DOMElements.msgKeyError.textContent = err || "";
                });
                DOMElements.iv.addEventListener("input", () => {
                    const config = UI_CONFIG.find((c) => c.mode === AppState.currentSettings.encryptionMode);
                    if (config && config.iv) {
                        const err = ValidationModule.validateInitialVector(DOMElements.iv.value);
                        DOMElements.msgIVError.textContent = err || "";
                    } else {
                        DOMElements.msgIVError.textContent = ""; // Clear if IV not needed
                    }
                });
            }

            function handleOptionGroupClick(event) {
                const selectedOption = event.target.closest(".option");
                if (selectedOption && !selectedOption.classList.contains("disabled")) {
                    const groupElement = this; // The group div itself
                    // Deselect other options in the same group
                    groupElement.querySelectorAll(".option").forEach((opt) => opt.classList.remove("selected"));
                    selectedOption.classList.add("selected"); // Select the clicked one

                    updateCurrentSetting(groupElement.id, selectedOption.dataset.value);
                    UIModule.toggleUI(); // Update UI based on new selection
                    // Clear relevant error messages when options change
                    if (groupElement.id === "encryptionMode" || groupElement.id === "keySize") {
                        DOMElements.msgKeyError.textContent = "";
                    }
                    if (groupElement.id === "encryptionMode") {
                        DOMElements.msgIVError.textContent = "";
                    }
                }
            }

            // ---- Generic Helpers ----
            function selectOptionByValue(groupElement, valueToSelect) {
                if (!groupElement) return;
                let optionFoundAndVisible = false;
                groupElement.querySelectorAll(".option").forEach((opt) => {
                    const isMatch = opt.dataset.value === valueToSelect;
                    const isVisible = opt.style.display !== "none";
                    if (isMatch && isVisible) {
                        opt.classList.add("selected");
                        optionFoundAndVisible = true;
                    } else {
                        opt.classList.remove("selected");
                    }
                });
                // If the target option was not found or not visible, select the first visible option as a fallback
                if (!optionFoundAndVisible) {
                    const firstVisibleOption = groupElement.querySelector(".option:not([style*='display: none'])");
                    if (firstVisibleOption) {
                        firstVisibleOption.classList.add("selected");
                        // Also update currentSettings if the original value was for a hidden option
                        if (AppState.currentSettings[groupElement.id] === valueToSelect) {
                            updateCurrentSetting(groupElement.id, firstVisibleOption.dataset.value);
                        }
                    }
                }
            }
        </script>
    </body>
</html>
