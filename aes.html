<!DOCTYPE html>
<html lang="zh-TW">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>é€²éš AES åŠ å¯†/è§£å¯†å·¥å…· (æ–‡å­—/æª”æ¡ˆ)</title>
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC&display=swap" rel="stylesheet" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
        <style>
            * {
                font-family: "Noto Sans TC", Arial, sans-serif;
            }
            body {
                transition: background-color 0.3s ease;
                font-size: 16px; /* Base font size */
            }
            body.encrypt-mode {
                background-color: #e6ffe6;
            }
            body.decrypt-mode {
                background-color: #ffe6e6;
            }
            .container {
                max-width: 80%;
                margin: 20px auto;
                padding: 20px;
                background-color: white;
                border-radius: 8px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            }
            .option-group {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 15px;
            }
            .option {
                padding: 10px 15px;
                border: 1px solid #ccc;
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.3s;
                user-select: none;
            }
            .option.selected {
                background-color: #007bff;
                color: white;
                border-color: #007bff;
            }
            .option.disabled {
                pointer-events: none;
                opacity: 0.5;
                cursor: not-allowed;
            }
            .input-group {
                margin-bottom: 15px;
            }
            label,
            .label-text {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
            }
            input[type="text"],
            input[type="file"],
            textarea {
                width: calc(100% - 22px);
                padding: 10px;
                border: 1px solid #ccc;
                border-radius: 4px;
                font-size: 1rem;
                box-sizing: border-box;
            }
            textarea {
                width: 100%;
            }
            .button-group {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-bottom: 15px;
            }
            button {
                padding: 10px 15px;
                background-color: #007bff;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1rem;
                transition: background-color 0.3s;
            }
            button:hover {
                background-color: #0056b3;
            }
            .encryptButton {
                width: 100%;
                margin: 20px 0;
                background-color: #28a745;
            }
            .encryptButton:hover {
                background-color: #1e7e34;
            }
            .decryptButton {
                width: 100%;
                margin: 20px 0;
                background-color: #dc3545;
            }
            .decryptButton:hover {
                background-color: #b02a37;
            }
            #FunctionEncrypt,
            #FunctionDecrypt {
                background-color: #6c757d;
                border-width: 1px;
                color: white;
            }
            #FunctionEncrypt.selected,
            #FunctionDecrypt.selected {
                background-color: #bb3d00;
            }
            .error-message {
                color: red;
                font-size: 1em;
            }
            .status-message {
                margin-top: 16px;
                padding: 10px;
                border-radius: 4px;
            }
            .status-success {
                background-color: #d4edda;
                color: #155724;
                border: 1px solid #c3e6cb;
            }
            .status-error {
                background-color: #f8d7da;
                color: #721c24;
                border: 1px solid #f5c6cb;
            }
            .note,
            .security-note,
            .best-practices {
                font-size: 0.9em;
                color: #721c24;
                background-color: #f8d7da;
                padding: 8px;
                border-radius: 4px;
                margin-top: 10px;
                margin-bottom: 20px;
            }
            .note {
                background-color: #baf1ac;
                color: #083b06;
                border-color: #a2f58d;
            }
            .best-practices {
                background-color: #fff3cd;
                color: #856404;
                border-color: #ffeeba;
            }
            .best-practices ul {
                margin: 5px 0 5px 20px;
                padding: 0;
            }
            .best-practices li {
                margin-bottom: 5px;
            }
            #aadGroup {
                display: none;
            }
            #fileInputGroup {
                margin-top: 15px;
            }
            #testResults {
                margin-top: 20px;
                border: 1px solid #eee;
                padding: 10px;
                background-color: #f9f9f9;
                white-space: pre-wrap;
                font-family: monospace;
                max-height: 300px;
                overflow-y: auto;
            }
            #testResults .pass {
                color: green;
            }
            #testResults .fail {
                color: red;
                font-weight: bold;
            }

            @media (max-width: 768px) {
                .container {
                    max-width: 95%;
                }
                .option {
                    flex: 1 1 48%;
                }
                .button-group {
                    flex-direction: column;
                }
            }
            @media (min-width: 769px) {
                .button-group {
                    flex-direction: row;
                    flex-wrap: wrap;
                }
                .button-group button {
                    flex: 1;
                    min-width: 100px;
                }
            }
        </style>
    </head>
    <body class="encrypt-mode">
        <div class="container">
            <h1>é€²éš AES åŠ å¯†/è§£å¯†å·¥å…·ï¼ˆæ–‡å­—/æª”æ¡ˆï¼‰</h1>

            <details class="best-practices">
                <summary>ğŸ” <strong>å®‰å…¨æ€§èˆ‡æœ€ä½³å¯¦è¸ï¼ˆé»æ“Šå±•é–‹ï¼‰</strong></summary>
                <ul>
                    <li>
                        <strong>é‡‘é‘°ç®¡ç†ï¼š</strong>
                        <ul>
                            <li>è«‹ä½¿ç”¨ç”±å¯†ç¢¼å­¸å®‰å…¨éš¨æ©Ÿæ•¸ç”¢ç”Ÿå™¨ (CSPRNG) ç”¢ç”Ÿçš„é‡‘é‘°ã€‚é¿å…ä½¿ç”¨å®¹æ˜“çŒœæ¸¬çš„å­—ä¸²ã€‚</li>
                            <li>æ­¤å·¥å…·ä¸­çš„é‡‘é‘°æ˜¯ç´”æ–‡å­—ï¼Œé•·åº¦å°‡ä¾æ“š UTF-8 ç·¨ç¢¼å¾Œçš„ä½å…ƒçµ„æ•¸è¨ˆç®—ã€‚</li>
                            <li>
                                è«‹å‹¿åœ¨ä¸å®‰å…¨çš„ç’°å¢ƒä¸­å„²å­˜æˆ–å‚³è¼¸æ‚¨çš„é‡‘é‘°ã€‚æ­¤å·¥å…·é©ç”¨æ–¼è‡¨æ™‚æ“ä½œï¼Œé‡‘é‘°å­˜åœ¨ç€è¦½å™¨è¨˜æ†¶é«”ä¸­ã€‚
                            </li>
                            <li>é‡‘é‘°é•·åº¦è¶Šé•· (å¦‚ 256 ä½å…ƒ) é€šå¸¸è¶Šå®‰å…¨ã€‚</li>
                        </ul>
                    </li>
                    <li>
                        <strong>åˆå§‹å‘é‡ (IV) / Nonceï¼š</strong>
                        <ul>
                            <li>
                                <strong>GCM/CTR æ¨¡å¼ï¼š</strong>IV (Nonce)
                                çµ•å°ä¸èƒ½é‡è¤‡ä½¿ç”¨æ–¼åŒä¸€é‡‘é‘°ä¸‹çš„ä¸åŒåŠ å¯†æ“ä½œã€‚é‡è¤‡ä½¿ç”¨æœƒåš´é‡å±åŠå®‰å…¨æ€§ã€‚å»ºè­°æ¯æ¬¡åŠ å¯†éƒ½ç”¢ç”Ÿæ–°çš„éš¨æ©Ÿ
                                IVã€‚IV é•·åº¦é€šå¸¸ç‚º 12 ä½å…ƒçµ„ (96 ä½å…ƒ)ï¼Œä½† Web Crypto API for GCM/CTR é€šå¸¸æ¥å— 16 ä½å…ƒçµ„
                                (128 ä½å…ƒ) IV ä¸¦å¯èƒ½åœ¨å…§éƒ¨æˆªæ–·æˆ–è™•ç†ã€‚æ­¤å·¥å…·é æœŸ UTF-8 ç·¨ç¢¼å¾Œç‚º 16 ä½å…ƒçµ„çš„ IV æ–‡å­—ã€‚
                            </li>
                            <li>
                                <strong>CBC æ¨¡å¼ï¼š</strong>IV å¿…é ˆæ˜¯ä¸å¯é æ¸¬çš„ (éš¨æ©Ÿçš„)ã€‚é›–ç„¶ä¸è¦æ±‚å”¯ä¸€ï¼Œä½†é‡è¤‡ä½¿ç”¨å·²çŸ¥
                                IV é…åˆç›¸åŒé‡‘é‘°å¯èƒ½æ´©æ¼éƒ¨åˆ†æ˜æ–‡è³‡è¨Šã€‚
                            </li>
                            <li>
                                <strong>ECB æ¨¡å¼ï¼š</strong>ä¸ä½¿ç”¨
                                IVï¼Œå› æ­¤ä¸å»ºè­°ç”¨æ–¼å¤§å¤šæ•¸æƒ…æ³ï¼Œå› å…¶æ¨¡å¼æœ¬èº«æœ‰å®‰å…¨æ€§ç¼ºé™·ã€‚
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>é™„åŠ é©—è­‰è³‡æ–™ (AAD)ï¼š</strong> (åƒ… GCM æ¨¡å¼)
                        <ul>
                            <li>AAD æ˜¯ä¸è¢«åŠ å¯†ä½†æœƒè¢«èªè­‰çš„è³‡æ–™ã€‚ä¾‹å¦‚ï¼Œè¨Šæ¯æ¨™é ­æˆ–å…ƒæ•¸æ“šã€‚</li>
                            <li>è§£å¯†æ™‚ï¼Œè‹¥ AAD èˆ‡åŠ å¯†æ™‚ä¸ç¬¦ï¼Œè§£å¯†æœƒå¤±æ•—ï¼Œç¢ºä¿è³‡æ–™å®Œæ•´æ€§èˆ‡çœŸå¯¦æ€§ã€‚</li>
                        </ul>
                    </li>
                    <li>
                        <strong>å‰ç«¯åŠ å¯†ï¼š</strong
                        >æ‰€æœ‰æ“ä½œå‡åœ¨æ‚¨çš„ç€è¦½å™¨ä¸­é€²è¡Œã€‚é›–ç„¶æ–¹ä¾¿ï¼Œä½†è«‹ç¢ºä¿æ‚¨çš„ç€è¦½å™¨å’Œé›»è…¦ç’°å¢ƒå®‰å…¨ã€‚
                    </li>
                </ul>
            </details>

            <div id="functionMode" class="option-group">
                <div id="FunctionEncrypt" class="option selected" data-value="encrypt">åŠ å¯†æ¨¡å¼</div>
                <div id="FunctionDecrypt" class="option" data-value="decrypt">è§£å¯†æ¨¡å¼</div>
            </div>

            <label class="label-text">è¼¸å…¥ä¾†æºï¼ˆInput Sourceï¼‰</label>
            <div id="inputSource" class="option-group">
                <div class="option selected" data-value="text">æ–‡å­—è¼¸å…¥</div>
                <div class="option" data-value="file">æª”æ¡ˆè¼¸å…¥</div>
            </div>

            <div id="textInputGroup" class="input-group">
                <label for="text">åŸå§‹æ–‡å­—ã€æ˜æ–‡ï¼ˆTextï¼‰</label>
                <div class="button-group">
                    <button id="copyTextButton">è¤‡è£½</button>
                    <button id="pasteTextButton">è²¼ä¸Š</button>
                    <button id="clearTextButton">æ¸…é™¤</button>
                </div>
                <textarea id="text" rows="5" placeholder="åœ¨æ­¤è¼¸å…¥è¦åŠ å¯†çš„æ˜æ–‡æˆ–è¦è§£å¯†çš„å¯†æ–‡ï¼ˆBase64/Hexï¼‰"></textarea>
            </div>

            <div id="fileInputGroup" class="input-group" style="display: none">
                <label for="fileInput">é¸æ“‡æª”æ¡ˆï¼ˆSelect Fileï¼‰</label>
                <input type="file" id="fileInput" />
                <span id="fileNameDisplay" class="note"></span>
            </div>

            <label class="label-text">åŠ å¯†æ¼”ç®—æ³•æ¨¡å¼ï¼ˆEncryption Modeï¼‰</label>
            <div id="encryptionMode" class="option-group">
                <div class="option selected" data-value="GCM">GCM</div>
                <div class="option" data-value="CTR">CTR</div>
                <div class="option" data-value="CBC">CBC</div>
                <div class="option" data-value="ECB">ECB</div>
            </div>
            <div class="security-note" id="ecbWarning" style="display: none">
                ğŸ” <strong>æ³¨æ„ï¼š</strong>ECB
                æ¨¡å¼é€šå¸¸ä¸å®‰å…¨ï¼Œå› ç‚ºç›¸åŒçš„æ˜æ–‡å¡ŠæœƒåŠ å¯†æˆç›¸åŒçš„å¯†æ–‡å¡Šã€‚å»ºè­°åƒ…åœ¨ç‰¹æ®Šæƒ…æ³ä¸‹ä½¿ç”¨ã€‚
            </div>

            <div id="paddingGroup" style="display: none">
                <label class="label-text">å¡«å……æ¨¡å¼ï¼ˆPaddingï¼‰</label>
                <div id="padding" class="option-group">
                    <div class="option selected" data-value="Pkcs7">PKCS7</div>
                    <div class="option" data-value="NoPadding">NoPadding</div>
                </div>
                <div class="note" id="noPaddingNote" style="display: none">
                    ğŸ” ä½¿ç”¨ NoPadding æ™‚ï¼ŒCBC / ECB æ¨¡å¼çš„æ˜æ–‡é•·åº¦ï¼ˆUTF-8 ç·¨ç¢¼å¾Œçš„ä½å…ƒçµ„ï¼‰å¿…é ˆæ˜¯ 16 çš„å€æ•¸ã€‚
                </div>
            </div>

            <label class="label-text">é‡‘é‘°é•·åº¦ï¼ˆEncryption Key Sizeï¼‰</label>
            <div id="keySize" class="option-group">
                <div class="option selected" data-value="128">128 ä½å…ƒ</div>
                <div class="option" data-value="192">192 ä½å…ƒ</div>
                <div class="option" data-value="256">256 ä½å…ƒ</div>
            </div>

            <div class="input-group">
                <label for="secretKey">é‡‘é‘°ï¼ˆSecret Keyï¼‰- ç´”æ–‡å­—æ ¼å¼</label>
                <input type="text" id="secretKey" placeholder="è¼¸å…¥é‡‘é‘°æ–‡å­—" />
                <div class="note">
                    ğŸ” é‡‘é‘°æ–‡å­—å°‡ä»¥ UTF-8 ç·¨ç¢¼ã€‚ç·¨ç¢¼å¾Œçš„ <strong>* ä½å…ƒçµ„é•·åº¦ *</strong> éœ€ç¬¦åˆæ‰€é¸é‡‘é‘°é•·åº¦ã€‚
                </div>
                <label id="msgKeyError" class="error-message"></label>
            </div>

            <div id="ivGroup" class="input-group">
                <label for="iv">åˆå§‹å‘é‡ï¼ˆIVï¼‰- ç´”æ–‡å­—æ ¼å¼</label>
                <div style="display: flex; gap: 10px; margin-bottom: 5px">
                    <input type="text" id="iv" placeholder="è¼¸å…¥ IV æ–‡å­— (é€šå¸¸éœ€ 16 ä½å…ƒçµ„)" style="flex-grow: 1" />
                    <button id="generateIvButton" style="padding: 8px 10px; font-size: 0.8em">ç”¢ç”Ÿéš¨æ©ŸIV</button>
                </div>
                <div class="note">
                    ğŸ” GCMã€CTRã€CBC æ¨¡å¼éœ€è¦ IVã€‚IV æ–‡å­—å°‡ä»¥ UTF-8 ç·¨ç¢¼ï¼Œç·¨ç¢¼å¾Œçš„
                    <strong>* ä½å…ƒçµ„é•·åº¦ *</strong> é€šå¸¸éœ€ç‚º 16 ä½å…ƒçµ„ã€‚<br />
                    ğŸ” <strong>é‡è¦ï¼š</strong>GCM / CTRæ¨¡å¼ä¸‹ï¼ŒåŒä¸€é‡‘é‘°æ¯æ¬¡åŠ å¯†çš„ IV å¿…é ˆå”¯ä¸€ï¼CBC æ¨¡å¼ä¸‹ IV
                    æ‡‰éš¨æ©Ÿä¸”ä¸å¯é æ¸¬ã€‚
                </div>
                <label id="msgIVError" class="error-message"></label>
            </div>

            <div id="aadGroup" class="input-group" style="display: none">
                <label for="aad">é™„åŠ é©—è­‰è³‡æ–™ï¼ˆAADï¼‰- ç´”æ–‡å­—æ ¼å¼ï¼ˆåƒ… GCM æ¨¡å¼ï¼‰</label>
                <textarea id="aad" rows="2" placeholder="è¼¸å…¥ AAD æ–‡å­—ï¼ˆå¯é¸ï¼‰"></textarea>
                <div class="note">ğŸ” AAD æ–‡å­—å°‡ä»¥ UTF-8 ç·¨ç¢¼ã€‚æ­¤è³‡æ–™ä¸æœƒè¢«åŠ å¯†ï¼Œä½†æœƒå½±éŸ¿èªè­‰æ¨™ç±¤ã€‚</div>
                <label id="msgAadError" class="error-message"></label>
            </div>

            <div id="tagLengthGroup" class="input-group" style="display: none">
                <label class="label-text">èªè­‰æ¨™ç±¤é•·åº¦ï¼ˆTag Length for GCMï¼‰</label>
                <div id="tagLength" class="option-group">
                    <div class="option selected" data-value="128">128 ä½å…ƒ</div>
                    <div class="option" data-value="120">120 ä½å…ƒ</div>
                    <div class="option" data-value="112">112 ä½å…ƒ</div>
                    <div class="option" data-value="104">104 ä½å…ƒ</div>
                    <div class="option" data-value="96">96 ä½å…ƒ</div>
                </div>
            </div>

            <div id="inputCiphertextFormatGroup" class="input-group" style="display: none">
                <label class="label-text">è¼¸å…¥å¯†æ–‡æ ¼å¼ï¼ˆInput Ciphertext Formatï¼‰</label>
                <div id="inputCiphertextFormat" class="option-group">
                    <div class="option selected" data-value="base64">Base64</div>
                    <div class="option" data-value="hex">Hex</div>
                </div>
            </div>

            <label class="label-text">è¼¸å‡ºæ ¼å¼ï¼ˆOutput Formatï¼‰</label>
            <div id="outputFormat" class="option-group">
                <div id="optTextFormat" class="option" data-value="plaintext">æ˜æ–‡ï¼ˆPlain-Textï¼‰</div>
                <div id="optBase64Format" class="option selected" data-value="base64">Base64</div>
                <div id="optHexFormat" class="option" data-value="hex">Hex</div>
                <div id="optBinaryFileFormat" class="option" data-value="binaryfile" style="display: none">
                    äºŒé€²ä½æª”æ¡ˆï¼ˆBinary Fileï¼‰
                </div>
            </div>

            <div class="button-group">
                <button id="btnExecute" class="encryptButton">åŠ å¯†ï¼ˆEncryptï¼‰</button>
            </div>

            <div class="input-group">
                <label for="result">çµæœï¼ˆResultï¼‰</label>
                <div class="button-group">
                    <button id="copyResultButton">è¤‡è£½</button>
                    <button id="clearResultButton">æ¸…é™¤</button>
                    <button id="swapTextResultButton">äº¤æ›</button>
                    <button id="resetFormButton">ğŸ” é‡ç½®</button>
                </div>
                <textarea id="result" rows="5" readonly placeholder="åŠ è§£å¯†çµæœå°‡é¡¯ç¤ºæ–¼æ­¤"></textarea>
            </div>

            <div id="status" class="status-message"></div>

            <hr />
            <button id="runTestsButton" style="background-color: #ffc107; color: black; margin-top: 10px">
                åŸ·è¡Œå–®å…ƒæ¸¬è©¦
            </button>
            <div id="testResults" style="display: none"><h4>æ¸¬è©¦çµæœï¼š</h4></div>
        </div>

        <script>
            // ---- Constants & Configuration ----
            const APP_NAME_SETTINGS = "aesAdvancedToolSettings";
            const UI_CONFIG = [
                { mode: "GCM", padding: 0, keySize: 1, iv: 1, tagLength: 1, aad: 1 },
                { mode: "CTR", padding: 0, keySize: 1, iv: 1, tagLength: 0, aad: 0 },
                { mode: "CBC", padding: 1, keySize: 1, iv: 1, tagLength: 0, aad: 0 },
                { mode: "ECB", padding: 1, keySize: 1, iv: 0, tagLength: 0, aad: 0 },
            ];
            const REQUIRED_IV_BYTE_LENGTH = 16; // Common IV length, esp. for WebCrypto default

            // ---- DOM Element Cache ----
            const DOMElements = {};

            function cacheDOMElements() {
                const ids = [
                    "functionMode",
                    "FunctionEncrypt",
                    "FunctionDecrypt",
                    "inputSource",
                    "textInputGroup",
                    "fileInputGroup",
                    "text",
                    "fileInput",
                    "fileNameDisplay",
                    "encryptionMode",
                    "ecbWarning",
                    "paddingGroup",
                    "padding",
                    "noPaddingNote",
                    "keySize",
                    "secretKey",
                    "msgKeyError",
                    "ivGroup",
                    "iv",
                    "generateIvButton",
                    "msgIVError",
                    "aadGroup",
                    "aad",
                    "msgAadError",
                    "tagLengthGroup",
                    "tagLength",
                    "inputCiphertextFormatGroup",
                    "inputCiphertextFormat",
                    "outputFormat",
                    "optTextFormat",
                    "optBase64Format",
                    "optHexFormat",
                    "optBinaryFileFormat",
                    "btnExecute",
                    "result",
                    "status",
                    "copyTextButton",
                    "pasteTextButton",
                    "clearTextButton",
                    "copyResultButton",
                    "clearResultButton",
                    "swapTextResultButton",
                    "resetFormButton",
                    "runTestsButton",
                    "testResults",
                ];
                ids.forEach((id) => (DOMElements[id] = document.getElementById(id)));
            }

            // ---- State Management & Settings (localStorage) ----
            const AppState = {
                currentSettings: {
                    functionMode: "encrypt",
                    inputSource: "text",
                    encryptionMode: "GCM",
                    padding: "Pkcs7",
                    keySize: "128",
                    tagLength: "128",
                    inputCiphertextFormat: "base64",
                    outputFormat: "base64",
                    // Do NOT store key, IV, text, AAD, or result here
                },
                isProcessing: false,
                loadedFileName: null,
                loadedFileBuffer: null,
            };

            function saveSettings() {
                try {
                    localStorage.setItem(APP_NAME_SETTINGS, JSON.stringify(AppState.currentSettings));
                } catch (e) {
                    console.warn("Could not save settings to localStorage:", e);
                }
            }

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(APP_NAME_SETTINGS);
                    if (saved) {
                        const parsedSettings = JSON.parse(saved);
                        // Sanitize/validate loaded settings if necessary before applying
                        Object.assign(AppState.currentSettings, parsedSettings);
                    }
                } catch (e) {
                    console.warn("Could not load settings from localStorage:", e);
                    // Fallback to default settings if parsing fails
                }
                applySettingsToUI();
            }

            function applySettingsToUI() {
                selectOptionByValue(DOMElements.functionMode, AppState.currentSettings.functionMode);
                selectOptionByValue(DOMElements.inputSource, AppState.currentSettings.inputSource);
                selectOptionByValue(DOMElements.encryptionMode, AppState.currentSettings.encryptionMode);
                selectOptionByValue(DOMElements.padding, AppState.currentSettings.padding);
                selectOptionByValue(DOMElements.keySize, AppState.currentSettings.keySize);
                selectOptionByValue(DOMElements.tagLength, AppState.currentSettings.tagLength);
                selectOptionByValue(DOMElements.inputCiphertextFormat, AppState.currentSettings.inputCiphertextFormat);
                // Output format default selection handled by toggleUI based on mode
                UIModule.toggleUI(); // Initial UI setup based on loaded/default settings
            }

            function updateCurrentSetting(groupId, value) {
                const groupToSettingMap = {
                    functionMode: "functionMode",
                    inputSource: "inputSource",
                    encryptionMode: "encryptionMode",
                    padding: "padding",
                    keySize: "keySize",
                    tagLength: "tagLength",
                    inputCiphertextFormat: "inputCiphertextFormat",
                    outputFormat: "outputFormat",
                };
                const settingKey = groupToSettingMap[groupId];
                if (settingKey && AppState.currentSettings.hasOwnProperty(settingKey)) {
                    AppState.currentSettings[settingKey] = value;
                    saveSettings();
                }
            }

            // ---- UI Module: Handles UI updates and interactions ----
            const UIModule = {
                toggleUI: function () {
                    const func = AppState.currentSettings.functionMode;
                    const mode = AppState.currentSettings.encryptionMode;
                    const inputSrc = AppState.currentSettings.inputSource;
                    const config = UI_CONFIG.find((c) => c.mode === mode);

                    if (!config) {
                        StatusModule.update(`æœªçŸ¥çš„åŠ å¯†æ¨¡å¼ï¼š'${mode}'`, true);
                        return;
                    }

                    // Input source (Text/File)
                    DOMElements.textInputGroup.style.display = inputSrc === "text" ? "block" : "none";
                    DOMElements.fileInputGroup.style.display = inputSrc === "file" ? "block" : "none";

                    DOMElements.paddingGroup.style.display = config.padding ? "block" : "none";
                    DOMElements.ivGroup.style.display = config.iv ? "block" : "none";
                    DOMElements.aadGroup.style.display = config.aad ? "block" : "none"; // AAD
                    DOMElements.tagLengthGroup.style.display = config.tagLength ? "block" : "none";
                    DOMElements.ecbWarning.style.display = mode === "ECB" ? "block" : "none";

                    if (config.padding) {
                        const paddingType = AppState.currentSettings.padding;
                        DOMElements.noPaddingNote.style.display = paddingType === "NoPadding" ? "block" : "none";
                    } else {
                        DOMElements.noPaddingNote.style.display = "none";
                    }

                    DOMElements.btnExecute.textContent = func === "encrypt" ? "åŠ å¯†ï¼ˆEncryptï¼‰" : "è§£å¯†ï¼ˆDecryptï¼‰";
                    DOMElements.btnExecute.className = func === "encrypt" ? "encryptButton" : "decryptButton";
                    document.body.className = func === "encrypt" ? "encrypt-mode" : "decrypt-mode";

                    DOMElements.inputCiphertextFormatGroup.style.display = func === "decrypt" ? "block" : "none";

                    // Output Format options
                    const isEncrypt = func === "encrypt";
                    DOMElements.optTextFormat.style.display = !isEncrypt ? "block" : "none";
                    DOMElements.optBase64Format.style.display = isEncrypt || inputSrc === "file" ? "block" : "none";
                    DOMElements.optHexFormat.style.display = isEncrypt || inputSrc === "file" ? "block" : "none";
                    DOMElements.optBinaryFileFormat.style.display =
                        (isEncrypt && inputSrc === "file") ||
                        (!isEncrypt && inputSrc === "file" && AppState.currentSettings.outputFormat === "binaryfile")
                            ? "block"
                            : "none";

                    // Default output format based on mode and input source
                    let defaultOutputOptionValue;
                    if (isEncrypt) {
                        defaultOutputOptionValue = inputSrc === "file" ? "binaryfile" : "base64";
                    } else {
                        // decrypt
                        defaultOutputOptionValue = inputSrc === "file" ? "binaryfile" : "plaintext";
                    }

                    // If current output format is not visible, switch to default
                    const currentOutputOptionEl = DOMElements.outputFormat.querySelector(
                        `.option[data-value='${AppState.currentSettings.outputFormat}']`
                    );
                    if (!currentOutputOptionEl || currentOutputOptionEl.style.display === "none") {
                        AppState.currentSettings.outputFormat = defaultOutputOptionValue;
                        saveSettings();
                    }
                    selectOptionByValue(DOMElements.outputFormat, AppState.currentSettings.outputFormat);

                    // Ensure a default selection for inputCiphertextFormat if decrypting
                    if (func === "decrypt" && !getSelectedValue(DOMElements.inputCiphertextFormatGroup)) {
                        selectOptionByValue(DOMElements.inputCiphertextFormatGroup, "base64");
                        AppState.currentSettings.inputCiphertextFormat = "base64";
                        saveSettings();
                    }
                    // Update placeholder for text input based on current mode
                    if (func === "encrypt") {
                        DOMElements.text.placeholder = "åœ¨æ­¤è¼¸å…¥è¦åŠ å¯†çš„æ˜æ–‡";
                    } else {
                        // decrypt
                        DOMElements.text.placeholder = "åœ¨æ­¤è¼¸å…¥è¦è§£å¯†çš„å¯†æ–‡ï¼ˆBase64/Hexï¼‰";
                    }
                },

                resetForm: function () {
                    [
                        DOMElements.text,
                        DOMElements.secretKey,
                        DOMElements.iv,
                        DOMElements.aad,
                        DOMElements.result,
                    ].forEach((el) => (el.value = ""));
                    DOMElements.fileInput.value = "";
                    AppState.loadedFileName = null;
                    AppState.loadedFileBuffer = null;
                    DOMElements.fileNameDisplay.textContent = "";

                    [DOMElements.msgKeyError, DOMElements.msgIVError, DOMElements.msgAadError].forEach(
                        (el) => (el.textContent = "")
                    );
                    StatusModule.clear();

                    // Reset to default AppState settings and apply
                    AppState.currentSettings = {
                        functionMode: "encrypt",
                        inputSource: "text",
                        encryptionMode: "GCM",
                        padding: "Pkcs7",
                        keySize: "128",
                        tagLength: "128",
                        inputCiphertextFormat: "base64",
                        outputFormat: "base64",
                    };
                    saveSettings();
                    applySettingsToUI();
                },

                handleFileUpload: function (event) {
                    const file = event.target.files[0];
                    if (!file) {
                        AppState.loadedFileName = null;
                        AppState.loadedFileBuffer = null;
                        DOMElements.fileNameDisplay.textContent = "";
                        return;
                    }
                    AppState.loadedFileName = file.name;
                    DOMElements.fileNameDisplay.textContent = `å·²é¸æ“‡æª”æ¡ˆ: ${file.name} (${(file.size / 1024).toFixed(
                        2
                    )} KB)`;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        AppState.loadedFileBuffer = e.target.result; // ArrayBuffer
                        // If encrypting a file, default output to binaryfile
                        if (AppState.currentSettings.functionMode === "encrypt") {
                            AppState.currentSettings.outputFormat = "binaryfile";
                            selectOptionByValue(DOMElements.outputFormat, "binaryfile");
                            saveSettings();
                            UIModule.toggleUI(); // Refresh UI for output format
                        }
                    };
                    reader.onerror = () => {
                        StatusModule.update("è®€å–æª”æ¡ˆå¤±æ•—ã€‚", true);
                        AppState.loadedFileName = null;
                        AppState.loadedFileBuffer = null;
                    };
                    reader.readAsArrayBuffer(file);
                },
            };

            // ---- Encoding/Decoding Utilities ----
            const EncodingUtils = {
                arrayBufferToBase64: function (buffer) {
                    /* Unchanged */
                    let binary = "";
                    const bytes = new Uint8Array(buffer);
                    for (let i = 0; i < bytes.byteLength; i++) {
                        binary += String.fromCharCode(bytes[i]);
                    }
                    return window.btoa(binary);
                },
                base64ToArrayBuffer: function (base64) {
                    /* Unchanged */
                    const binaryString = window.atob(base64);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    return bytes.buffer;
                },
                arrayBufferToHex: function (buffer) {
                    /* Unchanged */
                    return Array.from(new Uint8Array(buffer))
                        .map((b) => b.toString(16).padStart(2, "0"))
                        .join("");
                },
                hexToArrayBuffer: function (hex) {
                    /* Unchanged - but ensure robust error handling */
                    if (!/^[0-9a-fA-F]+$/.test(hex) || hex.length % 2 !== 0) {
                        throw new Error("ç„¡æ•ˆçš„ Hex å­—ä¸²æ ¼å¼ã€‚");
                    }
                    const bytes = new Uint8Array(hex.length / 2);
                    for (let i = 0; i < hex.length; i += 2) {
                        bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
                    }
                    return bytes.buffer;
                },
                stringToUtf8ArrayBuffer: function (str) {
                    return new TextEncoder().encode(str).buffer; // TextEncoder returns Uint8Array, get its buffer
                },
                utf8ArrayBufferToString: function (buffer) {
                    return new TextDecoder().decode(buffer);
                },
                generateRandomIVText: function () {
                    // Generates a Base64 representation of 16 random bytes
                    const randomBytes = new Uint8Array(REQUIRED_IV_BYTE_LENGTH);
                    window.crypto.getRandomValues(randomBytes);
                    // We need text for the IV input. Let's convert random bytes to a format that
                    // when UTF-8 encoded, results in 16 bytes. This is tricky if we allow arbitrary text.
                    // A safer bet is to generate 16 random bytes and represent them as Base64,
                    // then the user would have to ensure their *actual IV text* decodes to this.
                    // Simpler: generate random ASCII characters that are 1 byte each in UTF-8.
                    let ivText = "";
                    const PURE_ASCII_CHAR_SET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    for (let i = 0; i < REQUIRED_IV_BYTE_LENGTH; i++) {
                        ivText += PURE_ASCII_CHAR_SET.charAt(Math.floor(Math.random() * PURE_ASCII_CHAR_SET.length));
                    }
                    return ivText;
                },
            };

            // ---- Validation Module ----
            const ValidationModule = {
                validateAllInputs: function () {
                    DOMElements.msgKeyError.textContent = "";
                    DOMElements.msgIVError.textContent = "";
                    DOMElements.msgAadError.textContent = ""; // Clear AAD error

                    const secretKeyText = DOMElements.secretKey.value;
                    const keySize = parseInt(AppState.currentSettings.keySize);
                    const keyValidationError = this.validateSecretKey(secretKeyText, keySize);
                    if (keyValidationError) {
                        StatusModule.displayError(keyValidationError, DOMElements.msgKeyError);
                        return false;
                    }

                    const currentModeConfig = UI_CONFIG.find((c) => c.mode === AppState.currentSettings.encryptionMode);
                    if (currentModeConfig && currentModeConfig.iv) {
                        const ivText = DOMElements.iv.value;
                        const ivValidationError = this.validateInitialVector(ivText);
                        if (ivValidationError) {
                            StatusModule.displayError(ivValidationError, DOMElements.msgIVError);
                            return false;
                        }
                    }

                    if (currentModeConfig && currentModeConfig.aad) {
                        // AAD is optional, so only validate if present. Its length isn't strictly defined like keys/IVs.
                        // Here, we might just ensure it's valid UTF-8 or within a reasonable length if desired.
                        // For now, no specific validation beyond being parseable by TextEncoder.
                    }

                    // Validate NoPadding length for CBC/ECB encrypt
                    if (
                        AppState.currentSettings.functionMode === "encrypt" &&
                        (AppState.currentSettings.encryptionMode === "CBC" ||
                            AppState.currentSettings.encryptionMode === "ECB") &&
                        AppState.currentSettings.padding === "NoPadding"
                    ) {
                        let plainBytesLength;
                        if (AppState.currentSettings.inputSource === "text") {
                            const text = DOMElements.text.value;
                            plainBytesLength = new TextEncoder().encode(text).byteLength;
                        } else if (AppState.loadedFileBuffer) {
                            plainBytesLength = AppState.loadedFileBuffer.byteLength;
                        } else {
                            StatusModule.update(
                                "è­¦å‘Šï¼šä½¿ç”¨æª”æ¡ˆè¼¸å…¥ä½†æœªé¸æ“‡æª”æ¡ˆï¼Œç„¡æ³•é©—è­‰ NoPadding é•·åº¦ã€‚",
                                true,
                                "warning"
                            );
                            return true; // Or false if this should block
                        }

                        if (plainBytesLength % 16 !== 0) {
                            StatusModule.update(
                                `è­¦å‘Šï¼šä½¿ç”¨ NoPadding æ™‚ï¼Œæ˜æ–‡ï¼ˆUTF-8 ç·¨ç¢¼å¾Œæˆ–æª”æ¡ˆï¼‰é•·åº¦æ‡‰ç‚º 16 ä½å…ƒçµ„çš„å€æ•¸ã€‚ç›®å‰é•·åº¦ï¼š${plainBytesLength} ä½å…ƒçµ„ã€‚åŠ å¯†å¯èƒ½ç”¢ç”Ÿéé æœŸçµæœã€‚`,
                                true,
                                "warning-append"
                            );
                            // This is a warning, not a hard stop, so return true
                        }
                    }
                    return true;
                },

                validateSecretKey: function (secretKeyText, keySize) {
                    if (!secretKeyText) return "* é‡‘é‘°ç‚ºå¿…å¡«ã€‚";
                    const keyBytes = new TextEncoder().encode(secretKeyText); // Direct to Uint8Array
                    const actualByteLength = keyBytes.byteLength;
                    const requiredByteLength = keySize / 8;
                    if (actualByteLength !== requiredByteLength) {
                        return `* é‡‘é‘°ï¼ˆUTF-8 ç·¨ç¢¼å¾Œï¼‰ç‚º ${actualByteLength} ä½å…ƒçµ„ï¼Œä¸ç¬¦åˆé¸å®šé‡‘é‘°é•·åº¦æ‰€éœ€çš„ ${requiredByteLength} ä½å…ƒçµ„ã€‚`;
                    }
                    return null;
                },
                validateInitialVector: function (ivText) {
                    const currentMode = AppState.currentSettings.encryptionMode;
                    const config = UI_CONFIG.find((c) => c.mode === currentMode);

                    if (config && config.iv) {
                        // Only validate if IV is required by current mode config
                        if (!ivText) {
                            // IV is required and not provided
                            return "* IV ç‚ºå¿…å¡«ã€‚";
                        }
                        const ivBytes = new TextEncoder().encode(ivText);
                        const actualByteLength = ivBytes.byteLength;
                        if (actualByteLength !== REQUIRED_IV_BYTE_LENGTH) {
                            // Using constant
                            return `* IVï¼ˆUTF-8 ç·¨ç¢¼å¾Œï¼‰ç‚º ${actualByteLength} ä½å…ƒçµ„ï¼Œä¸ç¬¦åˆé€šå¸¸æ‰€éœ€çš„ ${REQUIRED_IV_BYTE_LENGTH} ä½å…ƒçµ„ã€‚`;
                        }
                    }
                    return null;
                },
            };

            // ---- Crypto Module ----
            const CryptoModule = {
                processData: async function () {
                    if (AppState.isProcessing) return;
                    AppState.isProcessing = true;
                    StatusModule.clear(); // Clear previous status first

                    if (!ValidationModule.validateAllInputs()) {
                        AppState.isProcessing = false;
                        return;
                    }

                    const operationFunc = AppState.currentSettings.functionMode;
                    const mode = AppState.currentSettings.encryptionMode;
                    const paddingValue =
                        DOMElements.paddingGroup.style.display !== "none"
                            ? AppState.currentSettings.padding
                            : "NoPadding";
                    const secretKeyText = DOMElements.secretKey.value;
                    const ivText = DOMElements.ivGroup.style.display !== "none" ? DOMElements.iv.value : "";
                    const aadText = DOMElements.aadGroup.style.display !== "none" ? DOMElements.aad.value : ""; // Get AAD text
                    const tagLength =
                        DOMElements.tagLengthGroup.style.display !== "none"
                            ? parseInt(AppState.currentSettings.tagLength)
                            : 128;
                    const outputFormat = AppState.currentSettings.outputFormat;
                    const inputCiphertextFormat =
                        operationFunc === "decrypt" ? AppState.currentSettings.inputCiphertextFormat : null;

                    let inputTextData; // This will be ArrayBuffer for file, or string for text
                    if (AppState.currentSettings.inputSource === "text") {
                        inputTextData = DOMElements.text.value;
                    } else if (AppState.loadedFileBuffer) {
                        inputTextData = AppState.loadedFileBuffer; // ArrayBuffer
                    } else {
                        StatusModule.update("éŒ¯èª¤ï¼šé¸æ“‡äº†æª”æ¡ˆè¼¸å…¥ä½†æœªæä¾›æª”æ¡ˆã€‚", true);
                        AppState.isProcessing = false;
                        return;
                    }

                    try {
                        let resultData; // This will typically be ArrayBuffer from crypto ops
                        if (operationFunc === "encrypt") {
                            resultData = await this.performEncryption(
                                mode,
                                inputTextData,
                                secretKeyText,
                                ivText,
                                aadText,
                                tagLength,
                                paddingValue
                            );
                        } else {
                            // decrypt
                            resultData = await this.performDecryption(
                                mode,
                                inputTextData,
                                secretKeyText,
                                ivText,
                                aadText,
                                tagLength,
                                paddingValue,
                                inputCiphertextFormat
                            );
                        }

                        // Handle output based on format
                        if (outputFormat === "plaintext") {
                            DOMElements.result.value = EncodingUtils.utf8ArrayBufferToString(resultData);
                        } else if (outputFormat === "base64") {
                            DOMElements.result.value = EncodingUtils.arrayBufferToBase64(resultData);
                        } else if (outputFormat === "hex") {
                            DOMElements.result.value = EncodingUtils.arrayBufferToHex(resultData);
                        } else if (outputFormat === "binaryfile") {
                            const outputFileName = HelperUtils.generateOutputFileName(
                                AppState.loadedFileName,
                                operationFunc
                            );
                            HelperUtils.downloadArrayBuffer(resultData, outputFileName);
                            DOMElements.result.value = `æª”æ¡ˆ "${outputFileName}" å·²é–‹å§‹ä¸‹è¼‰ã€‚`;
                        }

                        if (!StatusModule.hasWarning()) {
                            // Don't overwrite warnings (like NoPadding warning)
                            StatusModule.update(`${operationFunc === "encrypt" ? "åŠ å¯†" : "è§£å¯†"}æˆåŠŸ`, false);
                        }
                        if (
                            operationFunc === "decrypt" &&
                            (mode === "CBC" || mode === "ECB") &&
                            DOMElements.result.value === "" &&
                            inputTextData &&
                            (typeof inputTextData !== "string" || inputTextData.trim() !== "")
                        ) {
                            StatusModule.update(
                                "è§£å¯†æˆåŠŸï¼Œä½†çµæœç‚ºç©ºã€‚å¦‚æœåŸå§‹æ˜æ–‡éç©ºï¼Œé€™å¯èƒ½è¡¨ç¤ºè§£å¯†å¤±æ•— (ä¾‹å¦‚é‡‘é‘°éŒ¯èª¤æˆ–å¯†æ–‡æå£)ã€‚",
                                false,
                                "warning-append"
                            );
                        }
                    } catch (error) {
                        console.error("Processing Error:", error);
                        StatusModule.update(`éŒ¯èª¤: ${error.message || error}`, true);
                        if (
                            (error.message && error.message.toLowerCase().includes("decryption failed")) ||
                            (error.name && error.name === "OperationError")
                        ) {
                            StatusModule.update(
                                " (GCM/CTR æ¨¡å¼ä¸‹ï¼Œé€™é€šå¸¸è¡¨ç¤ºé‡‘é‘°ã€IVã€å¯†æ–‡æˆ– AAD ä¸åŒ¹é…ï¼Œæˆ–å¯†æ–‡å·²è¢«ç¯¡æ”¹)",
                                true,
                                "append"
                            );
                        }
                    } finally {
                        AppState.isProcessing = false;
                    }
                },

                performEncryption: async function (
                    mode,
                    plainData,
                    secretKeyText,
                    ivText,
                    aadText,
                    tagLength,
                    paddingValue
                ) {
                    const apiModeName = `AES-${mode.toUpperCase()}`;
                    let keyBytesForWebCrypto, ivBytesForWebCrypto, aadBytesForWebCrypto;
                    let plainBuffer; // ArrayBuffer

                    if (typeof plainData === "string") {
                        plainBuffer = EncodingUtils.stringToUtf8ArrayBuffer(plainData);
                    } else {
                        // Assumed ArrayBuffer (from file)
                        plainBuffer = plainData;
                    }

                    if (mode === "GCM" || mode === "CTR") {
                        keyBytesForWebCrypto = new TextEncoder().encode(secretKeyText); // Uint8Array
                        if (ivText) ivBytesForWebCrypto = new TextEncoder().encode(ivText); // Uint8Array
                        if (aadText && mode === "GCM") aadBytesForWebCrypto = new TextEncoder().encode(aadText); // Uint8Array

                        const cryptoKey = await window.crypto.subtle.importKey(
                            "raw",
                            keyBytesForWebCrypto,
                            { name: apiModeName },
                            false,
                            ["encrypt"]
                        );
                        const algorithm = { name: apiModeName, iv: ivBytesForWebCrypto };
                        if (mode === "GCM") {
                            algorithm.tagLength = tagLength;
                            if (aadBytesForWebCrypto) algorithm.additionalData = aadBytesForWebCrypto;
                        }
                        if (mode === "CTR") {
                            algorithm.counter = ivBytesForWebCrypto; // CTR uses IV as counter
                            algorithm.length = 64; // Add the required length property (e.g., 64 bits)
                        }

                        return await window.crypto.subtle.encrypt(algorithm, cryptoKey, plainBuffer); // Returns ArrayBuffer
                    } else {
                        // CBC or ECB using CryptoJS
                        const key = CryptoJS.enc.Utf8.parse(secretKeyText);
                        const iv = ivText ? CryptoJS.enc.Utf8.parse(ivText) : undefined;
                        const config = {
                            mode: CryptoJS.mode[mode],
                            padding: CryptoJS.pad[paddingValue],
                            ...(iv && { iv: iv }),
                        };
                        // CryptoJS expects string or WordArray. If plainBuffer is from file, convert.
                        const dataToEncrypt =
                            typeof plainData === "string" ? plainData : CryptoJS.lib.WordArray.create(plainBuffer);
                        const encrypted = CryptoJS.AES.encrypt(dataToEncrypt, key, config);
                        // Return ArrayBuffer for consistency with WebCrypto path
                        return EncodingUtils.hexToArrayBuffer(encrypted.ciphertext.toString(CryptoJS.enc.Hex));
                    }
                },

                performDecryption: async function (
                    mode,
                    cipherData,
                    secretKeyText,
                    ivText,
                    aadText,
                    tagLength,
                    paddingValue,
                    inputCiphertextFormat
                ) {
                    const apiModeName = `AES-${mode.toUpperCase()}`;
                    let dataToDecryptBuffer; // ArrayBuffer

                    if (typeof cipherData === "string") {
                        // Text input
                        if (inputCiphertextFormat === "base64") {
                            try {
                                dataToDecryptBuffer = EncodingUtils.base64ToArrayBuffer(cipherData);
                            } catch (e) {
                                throw new Error("è¼¸å…¥çš„ Base64 å¯†æ–‡æ ¼å¼ç„¡æ•ˆã€‚");
                            }
                        } else if (inputCiphertextFormat === "hex") {
                            try {
                                dataToDecryptBuffer = EncodingUtils.hexToArrayBuffer(cipherData);
                            } catch (e) {
                                throw new Error("è¼¸å…¥çš„ Hex å¯†æ–‡æ ¼å¼ç„¡æ•ˆã€‚");
                            }
                        } else {
                            throw new Error("æœªçŸ¥çš„è¼¸å…¥å¯†æ–‡æ ¼å¼ã€‚");
                        }
                    } else {
                        // File input (already ArrayBuffer)
                        dataToDecryptBuffer = cipherData;
                    }

                    if (mode === "GCM" || mode === "CTR") {
                        const keyBytesForWebCrypto = new TextEncoder().encode(secretKeyText); // Uint8Array
                        const ivBytesForWebCrypto = ivText ? new TextEncoder().encode(ivText) : undefined; // Uint8Array
                        let aadBytesForWebCrypto;
                        if (aadText && mode === "GCM") aadBytesForWebCrypto = new TextEncoder().encode(aadText); // Uint8Array

                        const cryptoKey = await window.crypto.subtle.importKey(
                            "raw",
                            keyBytesForWebCrypto,
                            { name: apiModeName },
                            false,
                            ["decrypt"]
                        );
                        const algorithm = { name: apiModeName, iv: ivBytesForWebCrypto };
                        if (mode === "GCM") {
                            algorithm.tagLength = tagLength;
                            if (aadBytesForWebCrypto) algorithm.additionalData = aadBytesForWebCrypto;
                        }
                        if (mode === "CTR") {
                            algorithm.counter = ivBytesForWebCrypto; // CTR uses IV as counter
                            algorithm.length = 64; // Add the required length property (e.g., 64 bits)
                        }

                        return await window.crypto.subtle.decrypt(algorithm, cryptoKey, dataToDecryptBuffer); // Returns ArrayBuffer
                    } else {
                        // CBC or ECB using CryptoJS
                        const key = CryptoJS.enc.Utf8.parse(secretKeyText);
                        const iv = ivText ? CryptoJS.enc.Utf8.parse(ivText) : undefined;
                        const config = {
                            mode: CryptoJS.mode[mode],
                            padding: CryptoJS.pad[paddingValue],
                            ...(iv && { iv: iv }),
                        };

                        // CryptoJS.AES.decrypt expects Base64 string or CipherParams object.
                        // dataToDecryptBuffer is an ArrayBuffer. Convert to Base64 for CryptoJS.
                        const ciphertextForCryptoJS = EncodingUtils.arrayBufferToBase64(dataToDecryptBuffer);

                        const decrypted = CryptoJS.AES.decrypt(ciphertextForCryptoJS, key, config);
                        try {
                            const decryptedHex = decrypted.toString(CryptoJS.enc.Hex);
                            if (
                                !decryptedHex &&
                                cipherData &&
                                (typeof cipherData !== "string" || cipherData.trim() !== "")
                            ) {
                                // Decryption might have "succeeded" but yielded empty, could be padding error or wrong key
                                // For consistency, return empty buffer rather than throwing here always. Status message handles this.
                                return new ArrayBuffer(0);
                            }
                            return EncodingUtils.hexToArrayBuffer(decryptedHex); // Return ArrayBuffer
                        } catch (e) {
                            // Error during Utf8 conversion often means bad decryption
                            console.error("CryptoJS Decryption to Utf8 Error:", e);
                            throw new Error(
                                "è§£å¯†æˆåŠŸï¼Œä½†çµæœç„¡æ³•æ­£ç¢ºè§£æç‚º UTF-8 æ–‡å­—ã€‚å¯èƒ½åŸå› ï¼šå¯†æ–‡å·²æå£ã€é‡‘é‘°/IV/æ¨¡å¼éŒ¯èª¤ã€‚"
                            );
                        }
                    }
                },
            };

            // ---- Status Message Module ----
            const StatusModule = {
                update: function (message, isError, mode = "normal") {
                    /* Unchanged, use DOMElements.status */
                    const statusElement = DOMElements.status;
                    if (mode === "append" || mode === "warning-append") {
                        statusElement.innerHTML += (statusElement.innerHTML ? "<br>" : "") + message; // Add line break if appending
                        if (mode === "warning-append") {
                            if (!statusElement.className.includes("status-success"))
                                statusElement.className = "status-message status-success"; // Keep success if already success
                        }
                    } else {
                        statusElement.textContent = message;
                        if (message) {
                            statusElement.className = isError
                                ? "status-message status-error"
                                : "status-message status-success";
                            if (mode === "warning") {
                                // A distinct warning that isn't a full error
                                statusElement.className = "status-message status-error"; // Or a specific warning class
                            }
                        } else {
                            statusElement.className = "status-message";
                        }
                    }
                },
                clear: function () {
                    this.update("", false);
                },
                displayError: function (message, element) {
                    // Changed from global displayError
                    if (element) element.textContent = message;
                    this.update("è¼¸å…¥é©—è­‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥éŒ¯èª¤è¨Šæ¯ã€‚", true);
                },
                hasWarning: function () {
                    // Check if status message contains a warning or if it's an error message that should be preserved
                    return (
                        DOMElements.status.textContent.toLowerCase().includes("è­¦å‘Š") ||
                        DOMElements.status.classList.contains("status-error")
                    );
                },
            };

            // ---- Helper/Utility Functions ----
            const HelperUtils = {
                copyToClipboard: function (elementId) {
                    /* Use DOMElements */
                    const element = DOMElements[elementId];
                    if (!element || typeof element.value === "undefined") {
                        StatusModule.update("è¤‡è£½ç›®æ¨™å…ƒç´ ä¸å­˜åœ¨æˆ–ç„¡å…§å®¹ã€‚", true);
                        return;
                    }
                    if (!element.value) {
                        StatusModule.update("æ²’æœ‰å…§å®¹å¯è¤‡è£½ã€‚", false, "warning");
                        return;
                    }
                    navigator.clipboard
                        .writeText(element.value)
                        .then(() => {
                            StatusModule.update("å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿", false);
                        })
                        .catch((err) => {
                            StatusModule.update("è¤‡è£½å¤±æ•—: " + err, true);
                        });
                },
                pasteFromClipboard: async function (elementId) {
                    /* Use DOMElements */
                    try {
                        const text = await navigator.clipboard.readText();
                        DOMElements[elementId].value = text;
                        StatusModule.update("å·²è²¼ä¸Šå…§å®¹ã€‚", false);
                    } catch (err) {
                        StatusModule.update("è²¼ä¸Šå¤±æ•—: ", err, true);
                    }
                },
                clearValue: function (elementId) {
                    DOMElements[elementId].value = "";
                },
                swapTextAndResult: function () {
                    /* Use DOMElements */
                    const textVal = DOMElements.text.value;
                    const resultVal = DOMElements.result.value;
                    DOMElements.text.value = resultVal;
                    DOMElements.result.value = textVal;
                    StatusModule.update("å·²äº¤æ›åŸå§‹æ–‡å­—èˆ‡çµæœæ–‡å­—", false);
                },
                downloadArrayBuffer: function (buffer, fileName) {
                    const blob = new Blob([buffer]);
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = fileName || "download.bin";
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    StatusModule.update(`æª”æ¡ˆ "${a.download}" å·²é–‹å§‹ä¸‹è¼‰ã€‚`, false);
                },
                generateOutputFileName: function (inputFileName, operation) {
                    const prefix = operation === "encrypt" ? "encrypted_" : "decrypted_";
                    const defaultName = operation === "encrypt" ? "encrypted_output.bin" : "decrypted_output.txt";
                    if (!inputFileName) return defaultName;

                    // Remove common encrypted/decrypted prefixes to avoid stacking them
                    let baseName = inputFileName.replace(/^(encrypted_|decrypted_)/i, "");

                    return prefix + baseName;
                },
            };

            // ---- Event Binding ----
            function bindEventListeners() {
                DOMElements.functionMode.addEventListener("click", handleOptionGroupClick);
                DOMElements.inputSource.addEventListener("click", handleOptionGroupClick);
                DOMElements.encryptionMode.addEventListener("click", handleOptionGroupClick);
                DOMElements.padding.addEventListener("click", handleOptionGroupClick);
                DOMElements.keySize.addEventListener("click", handleOptionGroupClick);
                DOMElements.tagLength.addEventListener("click", handleOptionGroupClick);
                DOMElements.inputCiphertextFormat.addEventListener("click", handleOptionGroupClick);
                DOMElements.outputFormat.addEventListener("click", handleOptionGroupClick);

                DOMElements.btnExecute.addEventListener("click", CryptoModule.processData.bind(CryptoModule));
                DOMElements.resetFormButton.addEventListener("click", UIModule.resetForm);

                // Text/Result area buttons
                DOMElements.copyTextButton.addEventListener("click", () => HelperUtils.copyToClipboard("text"));
                DOMElements.pasteTextButton.addEventListener("click", () => HelperUtils.pasteFromClipboard("text"));
                DOMElements.clearTextButton.addEventListener("click", () => HelperUtils.clearValue("text"));
                DOMElements.copyResultButton.addEventListener("click", () => HelperUtils.copyToClipboard("result"));
                DOMElements.clearResultButton.addEventListener("click", () => HelperUtils.clearValue("result"));
                DOMElements.swapTextResultButton.addEventListener("click", HelperUtils.swapTextAndResult);

                // File input
                DOMElements.fileInput.addEventListener("change", UIModule.handleFileUpload);
                // IV Generation
                DOMElements.generateIvButton.addEventListener("click", () => {
                    DOMElements.iv.value = EncodingUtils.generateRandomIVText();
                    // Manually trigger validation or status update if needed
                    ValidationModule.validateInitialVector(DOMElements.iv.value); // Example
                });

                // Run Tests Button
                DOMElements.runTestsButton.addEventListener("click", TestModule.runAllTests);
            }

            function handleOptionGroupClick(event) {
                const selectedOption = event.target.closest(".option");
                if (selectedOption && !selectedOption.classList.contains("disabled")) {
                    const groupElement = this; // The group that the event listener is attached to
                    groupElement.querySelectorAll(".option").forEach((opt) => opt.classList.remove("selected"));
                    selectedOption.classList.add("selected");

                    const selectedValue = selectedOption.dataset.value;
                    updateCurrentSetting(groupElement.id, selectedValue); // Update AppState and save

                    UIModule.toggleUI(); // Update UI based on new selection
                }
            }

            // Helper for setting selected option in a group
            function selectOptionByValue(groupElement, value) {
                if (!groupElement) return;
                const options = groupElement.querySelectorAll(".option");
                let found = false;
                options.forEach((opt) => {
                    if (opt.dataset.value === value) {
                        opt.classList.add("selected");
                        found = true;
                    } else {
                        opt.classList.remove("selected");
                    }
                });
                // If the desired value wasn't found (e.g. an old saved value for a removed option), select the first visible one
                if (!found) {
                    const firstVisibleOption = Array.from(options).find((opt) => opt.style.display !== "none");
                    if (firstVisibleOption) {
                        firstVisibleOption.classList.add("selected");
                        // Update AppState with this fallback value
                        updateCurrentSetting(groupElement.id, firstVisibleOption.dataset.value);
                    }
                }
            }

            // Helper to get selected value (used by toggleUI and others)
            function getSelectedValue(groupElement) {
                // Parameter is now the group DOM element
                if (!groupElement) return null;
                const selected = groupElement.querySelector(".option.selected");
                return selected ? selected.dataset.value : null;
            }

            // ---- Test Module (Simple Self-Contained Tests) ----
            const TestModule = {
                testResultsContainer: null,
                tests: [],

                init: function () {
                    this.testResultsContainer = DOMElements.testResults;
                    // Define tests
                    this.addTest("EncodingUtils.base64ToArrayBuffer and arrayBufferToBase64", async () => {
                        const original = "Hello World!";
                        const base64 = EncodingUtils.arrayBufferToBase64(
                            EncodingUtils.stringToUtf8ArrayBuffer(original)
                        );
                        const decoded = EncodingUtils.utf8ArrayBufferToString(
                            EncodingUtils.base64ToArrayBuffer(base64)
                        );
                        this.assertEqual(decoded, original, "Base64 encode/decode mismatch");
                    });

                    this.addTest("EncodingUtils.hexToArrayBuffer and arrayBufferToHex", async () => {
                        const original = "Hello Mars!";
                        const hex = EncodingUtils.arrayBufferToHex(EncodingUtils.stringToUtf8ArrayBuffer(original));
                        const decoded = EncodingUtils.utf8ArrayBufferToString(EncodingUtils.hexToArrayBuffer(hex));
                        this.assertEqual(decoded, original, "Hex encode/decode mismatch");
                    });

                    // Add a GCM encrypt/decrypt test
                    this.addTest("CryptoModule GCM Encrypt/Decrypt", async () => {
                        const plainText = "This is a GCM test!";
                        const keyText = "mygcmtestkey1234"; // 16 bytes
                        const ivText = "mygcmivtext12345"; // 16 bytes
                        const aadText = "mygcmAADdata";

                        const encryptedBuffer = await CryptoModule.performEncryption(
                            "GCM",
                            plainText,
                            keyText,
                            ivText,
                            aadText,
                            128,
                            "NoPadding"
                        );
                        this.assert(
                            encryptedBuffer && encryptedBuffer.byteLength > 0,
                            "GCM Encryption failed to produce output"
                        );

                        const decryptedBuffer = await CryptoModule.performDecryption(
                            "GCM",
                            encryptedBuffer,
                            keyText,
                            ivText,
                            aadText,
                            128,
                            "NoPadding",
                            null /* inputFormat not needed for buffer */
                        );
                        const decryptedText = EncodingUtils.utf8ArrayBufferToString(decryptedBuffer);
                        this.assertEqual(decryptedText, plainText, "GCM Decryption mismatch");
                    });

                    // Add a CBC PKCS7 encrypt/decrypt test
                    this.addTest("CryptoModule CBC-PKCS7 Encrypt/Decrypt", async () => {
                        const plainText = "CBC test with PKCS7."; // Not a multiple of 16
                        const keyText = "mycbckeyis16byte"; // 16 bytes
                        const ivText = "mycbcivtextis16b"; // 16 bytes

                        const encryptedBuffer = await CryptoModule.performEncryption(
                            "CBC",
                            plainText,
                            keyText,
                            ivText,
                            "",
                            0,
                            "Pkcs7"
                        );
                        this.assert(encryptedBuffer && encryptedBuffer.byteLength > 0, "CBC Encryption failed");

                        const decryptedBuffer = await CryptoModule.performDecryption(
                            "CBC",
                            encryptedBuffer,
                            keyText,
                            ivText,
                            "",
                            0,
                            "Pkcs7",
                            null
                        );
                        const decryptedText = EncodingUtils.utf8ArrayBufferToString(decryptedBuffer);
                        this.assertEqual(decryptedText, plainText, "CBC Decryption mismatch");
                    });

                    // Test ECB NoPadding (requires block alignment)
                    this.addTest("CryptoModule ECB-NoPadding Encrypt/Decrypt", async () => {
                        const plainText = "ECBNoPadding1234"; // 16 bytes
                        const keyText = "anotherkey16byte"; // 16 bytes

                        const encryptedBuffer = await CryptoModule.performEncryption(
                            "ECB",
                            plainText,
                            keyText,
                            "",
                            "",
                            0,
                            "NoPadding"
                        );
                        this.assert(encryptedBuffer && encryptedBuffer.byteLength > 0, "ECB Encryption failed");

                        const decryptedBuffer = await CryptoModule.performDecryption(
                            "ECB",
                            encryptedBuffer,
                            keyText,
                            "",
                            "",
                            0,
                            "NoPadding",
                            null
                        );
                        const decryptedText = EncodingUtils.utf8ArrayBufferToString(decryptedBuffer);
                        this.assertEqual(decryptedText, plainText, "ECB Decryption mismatch");
                    });
                },
                addTest: function (name, testFn) {
                    this.tests.push({ name, testFn });
                },
                runAllTests: async function () {
                    TestModule.testResultsContainer.innerHTML = "<h4>æ¸¬è©¦çµæœ:</h4>"; // Clear previous
                    TestModule.testResultsContainer.style.display = "block";
                    let passes = 0;
                    let failures = 0;

                    for (const test of TestModule.tests) {
                        const resultP = document.createElement("p");
                        try {
                            await test.testFn();
                            resultP.innerHTML = `PASS: ${test.name}`;
                            resultP.className = "pass";
                            passes++;
                        } catch (e) {
                            resultP.innerHTML = `FAIL: ${test.name} <br/>&nbsp;&nbsp;Error: ${e.message || e}`;
                            resultP.className = "fail";
                            console.error(`Test failed: ${test.name}`, e);
                            failures++;
                        }
                        TestModule.testResultsContainer.appendChild(resultP);
                    }

                    const summaryP = document.createElement("p");
                    summaryP.innerHTML = `<strong>ç¸½çµ: ${passes} é€šé, ${failures} å¤±æ•—.</strong>`;
                    TestModule.testResultsContainer.appendChild(summaryP);
                },
                // Basic assertion helpers
                assert: function (condition, message) {
                    if (!condition) throw new Error(message || "Assertion failed");
                },
                assertEqual: function (actual, expected, message) {
                    if (actual !== expected) {
                        throw new Error(message || `Expected "${expected}" but got "${actual}"`);
                    }
                },
            };

            // ---- Initialization ----
            document.addEventListener("DOMContentLoaded", () => {
                cacheDOMElements();
                loadSettings(); // Load settings and apply to UI (which also calls toggleUI)
                bindEventListeners();
                TestModule.init(); // Prepare tests but don't run them yet
                UIModule.toggleUI(); // Ensure UI is correctly set on initial load after settings
                StatusModule.update("å·¥å…·å·²å°±ç·’ã€‚", false);
            });
        </script>
    </body>
</html>
