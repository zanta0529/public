<!DOCTYPE html>
<html lang="zh-Hant" data-theme="dark">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Shamir's Secret Sharing Tool (Secrets.js Adapted Core)</title>
        <style>
            /* --- CSS 變數定義 (淺色 & 深色主題) --- */
            :root {
                --primary-color: #007bff;
                --primary-hover-color: #0056b3;
                --secondary-color: #6c757d;
                --secondary-hover-color: #5a6268;
                --bg-color: #f8f9fa;
                --container-bg: #ffffff;
                --text-color: #212529;
                --border-color: #dee2e6;
                --input-bg: #e9f5ff; /* Slightly bluish background */
                --input-focus-shadow: rgba(0, 123, 255, 0.25);
                --button-disabled-bg: #ccc;
                --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
                --table-header-bg: #f8f9fa;
                --error-color: #dc3545;
                --error-bg: #fbebeb;
                --success-color: #198754;
                --success-bg: #d1e7dd;
                --queue-item-bg: #e9ecef;
                --queue-item-border: #ced4da;
                --mode-btn-active-bg: var(--container-bg);
                --mode-btn-inactive-bg: var(--bg-color);
                --toast-bg: #323232;
                --toast-color: #fff;
                --qr-btn-color: #28a745; /* Green for QR Code button */
            }

            :root[data-theme="dark"] {
                --primary-color: #1e90ff;
                --primary-hover-color: #4ca8ff;
                --secondary-color: #778899;
                --secondary-hover-color: #90a0b1;
                --bg-color: #1e1e2f;
                --container-bg: #2f2f4f;
                --text-color: #e8e8f0;
                --border-color: #4a4a5f;
                --input-bg: #444;
                --input-focus-shadow: rgba(30, 144, 255, 0.4);
                --button-disabled-bg: #5a5a70;
                --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
                --table-header-bg: #252540;
                --error-color: #ff7f7f;
                --error-bg: #4f2e2e;
                --success-color: #60d978;
                --success-bg: #2a4a30;
                --queue-item-bg: #3a3a5f;
                --queue-item-border: #5a5a70;
                --mode-btn-active-bg: var(--container-bg);
                --mode-btn-inactive-bg: var(--bg-color);
                --toast-bg: #eaec6e;
                --toast-color: #1e1e2f;
                --qr-btn-color: #20c997;
            }

            /* --- 基礎 & 佈局樣式 --- */
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
                margin: 0;
                padding: 2rem;
                background-color: var(--bg-color);
                color: var(--text-color);
                line-height: 1.6;
                display: flex;
                flex-direction: column;
                align-items: center;
                min-height: 100vh;
                box-sizing: border-box;
                transition: background-color 0.3s, color 0.3s;
            }

            .container {
                background-color: var(--container-bg);
                padding: 2rem;
                border-radius: 8px;
                box-shadow: var(--box-shadow);
                width: 100%;
                max-width: 80%;
                margin-bottom: 2rem;
                border: 1px solid var(--border-color);
                transition: background-color 0.3s, border-color 0.3s;
            }

            h1 {
                text-align: center;
                margin-top: 0;
                margin-bottom: 1.5rem;
            }
            h2 {
                border-bottom: 2px solid var(--border-color);
                padding-bottom: 0.5rem;
                margin-bottom: 1.5rem;
                color: var(--primary-color);
            }

            /* --- 模式切換 (Tabs) --- */
            .mode-switcher {
                display: flex;
                border-bottom: 1px solid var(--border-color);
                margin-bottom: 2rem;
            }
            .mode-btn {
                padding: 0.75rem 1.5rem;
                border: none;
                border-bottom: 3px solid transparent;
                background-color: transparent;
                color: var(--secondary-color);
                font-size: 1.1rem;
                font-weight: 600;
                cursor: pointer;
                transition: color 0.3s, border-color 0.3s;
            }
            .mode-btn:hover {
                color: var(--primary-color);
            }
            .mode-btn.active {
                color: var(--primary-color);
                border-bottom-color: var(--primary-color);
            }

            .content-section {
                display: none;
            }
            .content-section.active {
                display: block;
                animation: fadeIn 0.5s ease;
            }
            @keyframes fadeIn {
                from {
                    opacity: 0;
                }
                to {
                    opacity: 1;
                }
            }

            /* --- 表單 & 輸入框 --- */
            .form-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 1.5rem;
                margin-bottom: 1.5rem;
            }
            .form-group {
                display: flex;
                flex-direction: column;
                padding-top: 10px;
            }
            label {
                margin-bottom: 0.5rem;
                font-weight: 600;
            }
            textarea,
            input {
                width: 100%;
                padding: 0.75rem;
                border: 1px solid var(--border-color);
                border-radius: 5px;
                box-sizing: border-box;
                font-size: 1em;
                background-color: var(--input-bg);
                color: var(--text-color);
                transition: 0.3s;
            }
            textarea:focus,
            input:focus {
                outline: none;
                border-color: var(--primary-color);
                box-shadow: 0 0 0 0.2rem var(--input-focus-shadow);
            }
            .input-error-message {
                font-size: 0.8em;
                color: var(--error-color);
                min-height: 1.2em;
                margin-top: 0.25rem;
            }

            /* --- 按鈕 --- */
            .button-group {
                display: flex;
                gap: 1rem;
                margin-top: 1.5rem;
            }
            button {
                padding: 0.75rem 1.5rem;
                background-color: var(--primary-color);
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1em;
                font-weight: 600;
                transition: background-color 0.3s, transform 0.1s;
            }
            button.secondary {
                background-color: var(--secondary-color);
            }
            button.qr {
                background-color: var(--qr-btn-color);
            }
            button.secondary:hover:not(:disabled) {
                background-color: var(--secondary-hover-color);
            }
            button:hover:not(:disabled) {
                filter: brightness(110%);
                transform: translateY(-1px);
            }
            button:disabled {
                background-color: var(--button-disabled-bg);
                cursor: not-allowed;
                opacity: 0.7;
            }
            .action-btn {
                font-size: 0.8em;
                padding: 0.3rem 0.6rem;
            }
            .action-button-container {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
                justify-content: center;
            }

            /* --- 結果與表格 --- */
            #splitResultArea,
            #reconstructionResult {
                margin-top: 2rem;
            }
            table {
                width: 100%;
                border-collapse: collapse;
                table-layout: fixed;
            }
            th,
            td {
                padding: 0.75rem;
                border: 1px solid var(--border-color);
                text-align: left;
                vertical-align: middle;
                word-break: break-all;
            }
            th {
                background-color: var(--table-header-bg);
                font-weight: 600;
            }
            td:last-child {
                width: 150px; /* 給操作欄一個固定寬度 */
            }

            /* --- 重建佇列 --- */
            #reconstructionQueue {
                border: 1px dashed var(--border-color);
                border-radius: 5px;
                padding: 1rem;
                min-height: 100px;
                margin-bottom: 1.5rem;
            }
            .queue-progress {
                text-align: center;
                color: var(--secondary-color);
                font-weight: 600;
                margin-bottom: 1rem;
            }
            .queue-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                background-color: var(--queue-item-bg);
                padding: 0.5rem 1rem;
                border-radius: 5px;
                margin-bottom: 0.5rem;
                font-family: monospace;
                font-size: 0.9em;
            }
            .queue-item button {
                background-color: var(--error-color);
            }

            /* --- 輸出/錯誤提示 --- */
            .output-box {
                padding: 1rem;
                border-radius: 5px;
                white-space: pre-wrap;
                word-break: break-all;
                min-height: 50px;
                font-size: 1.1em;
                line-height: 1.5;
                border-left: 5px solid;
                margin-top: 1.5rem;
            }
            .output-box.error {
                color: var(--error-color);
                border-color: var(--error-color);
                background-color: var(--error-bg);
            }
            .output-box.success {
                color: var(--success-color);
                border-color: var(--success-color);
                background-color: var(--success-bg);
            }

            /* --- 頁尾 --- */
            footer {
                text-align: center;
                margin-top: 2rem;
                font-size: 0.9em;
                color: var(--secondary-color);
            }
            #themeToggleBtn {
                background: none;
                border: 1px solid var(--border-color);
                color: var(--text-color);
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1.2em;
                margin-left: 10px;
                vertical-align: middle;
                transition: 0.3s;
            }
            #themeToggleBtn:hover {
                background-color: var(--border-color);
            }

            /* --- QR Code Modal --- */
            #qrModal {
                display: none; /* Hidden by default */
                position: fixed;
                z-index: 1000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0, 0, 0, 0.7);
                justify-content: center;
                align-items: center;
                cursor: pointer; /* Allow clicking anywhere to close */
            }
            #qrCodeContainer {
                background-color: #fff;
                padding: 20px;
                border-radius: 8px;
                cursor: default; /* Prevent modal close when clicking on QR itself */
            }
            #qrCodeContainer img {
                /* Ensure QR image is responsive if library generates one */
                display: block;
                max-width: 100%;
                height: auto;
            }

            /* --- Toast Notification --- */
            #toast {
                visibility: hidden;
                min-width: 250px;
                background-color: var(--toast-bg);
                color: var(--toast-color);
                text-align: center;
                border-radius: 2px;
                padding: 16px;
                position: fixed;
                z-index: 1001;
                left: 50%;
                transform: translateX(-50%);
                bottom: 30px;
                font-size: 17px;
                border-radius: 5px;
                opacity: 0;
                transition: opacity 0.5s, visibility 0.5s;
            }

            #toast.show {
                visibility: visible;
                opacity: 1;
            }

            /* --- 響應式設計 --- */
            @media (max-width: 768px) {
                body {
                    padding: 1rem;
                }
                .container {
                    padding: 1.5rem;
                    max-width: 95%;
                }
                .form-grid {
                    grid-template-columns: 1fr;
                }
                .mode-btn {
                    padding: 0.75rem 1rem;
                    font-size: 1rem;
                }
                table,
                thead,
                tbody,
                th,
                td,
                tr {
                    display: block;
                }
                thead tr {
                    position: absolute;
                    top: -9999px;
                    left: -9999px;
                }
                tr {
                    border: 1px solid var(--border-color);
                    margin-bottom: 1rem;
                }
                td {
                    border: none;
                    border-bottom: 1px solid var(--border-color);
                    position: relative;
                    padding-left: 50%;
                }
                td:before {
                    position: absolute;
                    top: 50%;
                    transform: translateY(-50%);
                    left: 6px;
                    width: 45%;
                    padding-right: 10px;
                    white-space: nowrap;
                    font-weight: bold;
                }
                td:nth-of-type(1):before {
                    content: "ID";
                }
                td:nth-of-type(2):before {
                    content: "Base64 分割值";
                }
                td:nth-of-type(3):before {
                    content: "操作";
                }
                td:last-child {
                    width: auto;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Zanta's Shamir's Secret Sharing Tool (Secrets.js Adapted Core)</h1>

            <div class="mode-switcher">
                <button id="modeSplitBtn" class="mode-btn active">分割</button>
                <button id="modeReconstructBtn" class="mode-btn">重建</button>
            </div>

            <div id="splitSection" class="content-section active">
                <h2>分割秘密</h2>
                <div class="form-group">
                    <label for="originalString">原始字串</label>
                    <textarea id="originalString" rows="3" placeholder="請在此輸入任何您想加密保護的文字..."></textarea>
                </div>
                <div class="form-grid">
                    <div class="form-group">
                        <label for="n">總分割數 (n)</label>
                        <input type="number" id="n" min="2" max="255" placeholder="e.g., 5" />
                        <div id="nErrorMessage" class="input-error-message"></div>
                    </div>
                    <div class="form-group">
                        <label for="k">重建門檻值 (k)</label>
                        <input type="number" id="k" min="2" max="255" placeholder="e.g., 3" />
                        <div id="kErrorMessage" class="input-error-message"></div>
                    </div>
                </div>
                <div id="splitError" class="output-box error" style="display: none"></div>
                <div class="button-group">
                    <button id="generateBtn">產生分割值</button>
                    <button id="clearSplitBtn" class="secondary">清除</button>
                </div>
                <div id="splitResultArea" style="display: none">
                    <h2>分割結果</h2>
                    <table id="splitResultTable">
                        <thead>
                            <tr>
                                <th style="width: 30px">ID</th>
                                <th>Base64 分割值</th>
                                <th style="width: 150px">操作</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div id="reconstructSection" class="content-section">
                <h2>重建秘密</h2>

                <div id="reconstructionQueue">
                    <div id="queueProgress" class="queue-progress">請從「分割」頁面加入分割值，或從下方手動貼上</div>
                    <div id="queueList"></div>
                </div>

                <div class="form-group">
                    <label for="customShareInput">手動貼上 Base64 分割值</label>
                    <textarea id="customShareInput" rows="2" placeholder="貼上 Base64 編碼的分割值..."></textarea>
                    <div class="button-group" style="margin-top: 0.5rem; justify-content: flex-end">
                        <button id="addCustomShareBtn" class="secondary" style="flex: 0 1 auto">加入佇列</button>
                    </div>
                </div>

                <div id="reconstructionResult" class="output-box" style="display: none"></div>

                <div class="button-group">
                    <button id="reconstructBtn">重建秘密</button>
                    <button id="clearQueueBtn" class="secondary">清空佇列</button>
                </div>
            </div>
        </div>
        <footer>
            <p>
                &copy; <span id="currentYear"></span> Zanta's Shamir's Secret Sharing Tool (Secrets.js Adapted Core)
                <button id="themeToggleBtn" title="切換主題">🌙</button>
            </p>
        </footer>

        <div id="qrModal">
            <div id="qrCodeContainer" onclick="event.stopPropagation()"></div>
        </div>

        <div id="toast"></div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

        <script>
            const THEME_KEY = "zanta-shamir-secret-sharing-theme";

            /**
             * SSS implementation using core logic adapted from secrets.js principles.
             * This version aims for correctness by leveraging proven GF(2^8) arithmetic.
             * Enhanced and Corrected by CAN. I love coding.
             */
            class ShamirSecretsAdapter {
                constructor(secret, n, k) {
                    if (n < 2 || k < 2 || k > n || n > 255 || k > 255) {
                        throw new Error("k 和 n 必須是 2 到 255 之間的整數，且 k <= n。");
                    }
                    if (typeof secret !== "string") {
                        // Empty string is allowed for now, will be padded
                        throw new Error("秘密必須是字串。");
                    }

                    this.n = n;
                    this.k = k;

                    // GF(2^8) settings from secrets.js (using primitive polynomial 0x1D for 8-bit)
                    this.config = {
                        bits: 8,
                        radix: 16, // For internal hex conversions if needed
                        maxShares: 255, // 2^8 - 1
                        primitivePolynomials: [null, null, 1, 3, 3, 5, 3, 3, 29], // Only up to 8 for brevity, 29 is 0x1D for 8-bit
                        logs: new Array(256),
                        exps: new Array(256),
                    };
                    this._secretsJS_initGF(this.config.bits);

                    // Data preparation similar to secrets.js: string -> hex -> binary string -> "1"-prefixed -> pad binary string
                    const hexSecret = this._str2hex(secret); // UTF-8 string to hex
                    let binarySecret = "1" + this._hex2bin(hexSecret); // Prepend "1" marker

                    // Pad the binary string to be a multiple of config.bits (8 bits)
                    // This is different from PKCS#7. secrets.js pads the binary string itself.
                    const bits = this.config.bits;
                    const missingBits = binarySecret.length % bits;
                    if (missingBits) {
                        binarySecret = "0".repeat(bits - missingBits) + binarySecret;
                    }
                    this.processedSecretElements = this._splitNumStringToIntArray(binarySecret, bits);
                }

                _secretsJS_initGF(bits) {
                    const primitive = this.config.primitivePolynomials[bits];
                    if (!primitive) throw new Error(`Unsupported bit size for GF: ${bits}`);

                    let x = 1;
                    for (let i = 0; i < this.config.maxShares; i++) {
                        // Iterate 255 times for GF(2^8)
                        this.config.exps[i] = x;
                        this.config.logs[x] = i;
                        x <<= 1;
                        if (x >= 256) {
                            // For GF(2^8), size is 256
                            x ^= primitive;
                            x &= this.config.maxShares; // Ensure x is within 0-255 range
                        }
                    }
                    // For log[0], it will remain 0 from Array initialization. Multiply/Divide by 0 handled separately.
                }

                // --- String/Hex/Binary Utilities (adapted from secrets.js) ---
                _padLeft(str, multipleOfBits) {
                    let missing = str.length % multipleOfBits;
                    if (missing) {
                        return "0".repeat(multipleOfBits - missing) + str;
                    }
                    return str;
                }

                _str2hex(str) {
                    // UTF-8 to Hex
                    let hex = "";
                    for (let i = 0; i < str.length; i++) {
                        let charCode = str.charCodeAt(i);
                        if (charCode < 0x80) {
                            hex += charCode.toString(16).padStart(2, "0");
                        } else if (charCode < 0x800) {
                            hex += (0xc0 | (charCode >> 6)).toString(16).padStart(2, "0");
                            hex += (0x80 | (charCode & 0x3f)).toString(16).padStart(2, "0");
                        } else if (charCode < 0xd800 || charCode >= 0xe000) {
                            hex += (0xe0 | (charCode >> 12)).toString(16).padStart(2, "0");
                            hex += (0x80 | ((charCode >> 6) & 0x3f)).toString(16).padStart(2, "0");
                            hex += (0x80 | (charCode & 0x3f)).toString(16).padStart(2, "0");
                        } else {
                            // UTF-16 surrogate pairs
                            charCode = 0x10000 + (((charCode & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
                            hex += (0xf0 | (charCode >> 18)).toString(16).padStart(2, "0");
                            hex += (0x80 | ((charCode >> 12) & 0x3f)).toString(16).padStart(2, "0");
                            hex += (0x80 | ((charCode >> 6) & 0x3f)).toString(16).padStart(2, "0");
                            hex += (0x80 | (charCode & 0x3f)).toString(16).padStart(2, "0");
                        }
                    }
                    return hex;
                }

                _hex2bin(hexStr) {
                    let bin = "";
                    for (let i = 0; i < hexStr.length; i++) {
                        let num = parseInt(hexStr[i], 16);
                        if (isNaN(num)) throw new Error("Invalid hex character in _hex2bin.");
                        bin += num.toString(2).padStart(4, "0");
                    }
                    return bin;
                }

                _bin2hex(binStr) {
                    let hex = "";
                    // Ensure binary string length is a multiple of 4
                    binStr = this._padLeft(binStr, 4);
                    for (let i = 0; i < binStr.length; i += 4) {
                        let chunk = binStr.substring(i, i + 4);
                        hex += parseInt(chunk, 2).toString(16);
                    }
                    return hex;
                }

                _hex2str(hexStr) {
                    // Hex to UTF-8 string
                    let str = "";
                    let i = 0;
                    while (i < hexStr.length) {
                        let charCode;
                        let byte1 = parseInt(hexStr.substring(i, i + 2), 16);
                        i += 2;
                        if (byte1 < 0x80) {
                            // 1-byte sequence
                            charCode = byte1;
                        } else if ((byte1 & 0xe0) === 0xc0) {
                            // 2-byte sequence
                            let byte2 = parseInt(hexStr.substring(i, i + 2), 16);
                            i += 2;
                            charCode = ((byte1 & 0x1f) << 6) | (byte2 & 0x3f);
                        } else if ((byte1 & 0xf0) === 0xe0) {
                            // 3-byte sequence
                            let byte2 = parseInt(hexStr.substring(i, i + 2), 16);
                            i += 2;
                            let byte3 = parseInt(hexStr.substring(i, i + 2), 16);
                            i += 2;
                            charCode = ((byte1 & 0x0f) << 12) | ((byte2 & 0x3f) << 6) | (byte3 & 0x3f);
                        } else if ((byte1 & 0xf8) === 0xf0) {
                            // 4-byte sequence
                            let byte2 = parseInt(hexStr.substring(i, i + 2), 16);
                            i += 2;
                            let byte3 = parseInt(hexStr.substring(i, i + 2), 16);
                            i += 2;
                            let byte4 = parseInt(hexStr.substring(i, i + 2), 16);
                            i += 2;
                            charCode =
                                ((byte1 & 0x07) << 18) |
                                ((byte2 & 0x3f) << 12) |
                                ((byte3 & 0x3f) << 6) |
                                (byte4 & 0x3f);
                        } else {
                            throw new Error("Invalid UTF-8 sequence in hex string.");
                        }
                        str += String.fromCodePoint(charCode);
                    }
                    return str;
                }

                _splitNumStringToIntArray(binaryString, bitsPerChunk) {
                    const parts = [];
                    for (let i = 0; i < binaryString.length; i += bitsPerChunk) {
                        parts.push(parseInt(binaryString.substring(i, i + bitsPerChunk), 2));
                    }
                    return parts;
                }

                _getRandomByte() {
                    const buffer = new Uint8Array(1);
                    window.crypto.getRandomValues(buffer);
                    return buffer[0];
                }

                // Polynomial evaluation at `x` using Horner's Method (adapted from secrets.js `horner`)
                // P(X) = coeffs[0] + coeffs[1]*X + ... + coeffs[k-1]*X^(k-1) where coeffs[0] is secret part
                _evalPolynomialSJS(x_coord, coeffs_poly) {
                    // coeffs_poly is [secretPart, r1, r2, ..., r_{k-1}]
                    let fx = 0;
                    const logx = this.config.logs[x_coord];

                    for (let i = coeffs_poly.length - 1; i >= 0; i--) {
                        if (fx === 0) {
                            fx = coeffs_poly[i];
                        } else {
                            // fx = (fx * x_coord) ^ coeffs_poly[i]
                            fx =
                                this.config.exps[(logx + this.config.logs[fx]) % this.config.maxShares] ^
                                coeffs_poly[i];
                        }
                    }
                    return fx;
                }

                generateShares() {
                    const shares = [];
                    for (let i = 0; i < this.n; i++) {
                        shares[i] = { id: i + 1, value: new Array(this.processedSecretElements.length) };
                    }

                    for (let elementIndex = 0; elementIndex < this.processedSecretElements.length; elementIndex++) {
                        const secretElement = this.processedSecretElements[elementIndex];
                        const coeffs = [secretElement]; // Zeroth coefficient is the secret element
                        for (let i = 1; i < this.k; i++) {
                            coeffs[i] = this._getRandomByte();
                        }

                        for (let shareIndex = 0; shareIndex < this.n; shareIndex++) {
                            const x = shares[shareIndex].id;
                            shares[shareIndex].value[elementIndex] = this._evalPolynomialSJS(x, coeffs);
                        }
                    }
                    return shares;
                }

                // Lagrange interpolation (adapted from secrets.js `lagrange`)
                // Interpolates to find P(0) which is the secret element
                _reconstructElementSJS(x_coords, y_coords) {
                    let sum = 0;
                    const at = 0; // We are reconstructing P(0)

                    for (let i = 0; i < this.k; i++) {
                        // Iterate through the k shares provided
                        if (y_coords[i] === 0) continue; // Term will be 0 if y_coord is 0

                        let product = this.config.logs[y_coords[i]]; // log(y_i)

                        for (let j = 0; j < this.k; j++) {
                            if (i === j) continue;
                            // L_i(0) = product_{j!=i} ( (at - x_j) / (x_i - x_j) )
                            // In GF(2^N) with at=0: product_{j!=i} ( x_j / (x_i XOR x_j) )
                            // product = log(y_i) + sum_{j!=i} ( log(x_j) - log(x_i XOR x_j) )
                            if (at === x_coords[j]) {
                                // Should not happen if reconstructing at 0 and x_coords are share IDs (>=1)
                                product = -1;
                                break;
                            }
                            product =
                                (product +
                                    this.config.logs[at ^ x_coords[j]] -
                                    this.config.logs[x_coords[i] ^ x_coords[j]] +
                                    this.config.maxShares) %
                                this.config.maxShares;
                        }
                        sum = product === -1 ? sum : sum ^ this.config.exps[product];
                    }
                    return sum;
                }

                reconstructSecret(inputShares) {
                    if (inputShares.length < this.k) {
                        throw new Error(`至少需要 ${this.k} 份分割值才能重建。`);
                    }
                    const sharesToUse = inputShares.slice(0, this.k);

                    const numElements = sharesToUse[0].value.length;
                    if (!sharesToUse.every((s) => s.value.length === numElements)) {
                        throw new Error("所有用於重建的分割值長度必須一致。");
                    }

                    let reconstructedBinaryString = "";
                    const x_coords = sharesToUse.map((s) => s.id);

                    for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {
                        const y_coords_for_element = sharesToUse.map((s) => s.value[elementIndex]);
                        const reconstructedElement = this._reconstructElementSJS(x_coords, y_coords_for_element);
                        reconstructedBinaryString += this._padLeft(reconstructedElement.toString(2), this.config.bits);
                    }

                    // Remove the "1" marker and any padding
                    const originalBinaryData = reconstructedBinaryString.slice(
                        reconstructedBinaryString.indexOf("1") + 1
                    );

                    // Ensure originalBinaryData length is multiple of 4 for hex conversion, if it was padded to be multiple of 8 then it is.
                    const hexSecret = this._bin2hex(originalBinaryData);
                    return this._hex2str(hexSecret);
                }
            }

            document.addEventListener("DOMContentLoaded", () => {
                let sssInstance = null;
                let reconstructionQueue = [];

                const modeSplitBtn = document.getElementById("modeSplitBtn");
                const modeReconstructBtn = document.getElementById("modeReconstructBtn");
                const splitSection = document.getElementById("splitSection");
                const reconstructSection = document.getElementById("reconstructSection");
                const originalString = document.getElementById("originalString");
                const nInput = document.getElementById("n");
                const kInput = document.getElementById("k");
                const kErrorMessage = document.getElementById("kErrorMessage");
                const generateBtn = document.getElementById("generateBtn");
                const clearSplitBtn = document.getElementById("clearSplitBtn");
                const splitError = document.getElementById("splitError");
                const splitResultArea = document.getElementById("splitResultArea");
                const splitResultTableBody = document.querySelector("#splitResultTable tbody");
                const queueProgress = document.getElementById("queueProgress");
                const queueList = document.getElementById("queueList");
                const customShareInput = document.getElementById("customShareInput");
                const addCustomShareBtn = document.getElementById("addCustomShareBtn");
                const reconstructBtn = document.getElementById("reconstructBtn");
                const clearQueueBtn = document.getElementById("clearQueueBtn");
                const reconstructionResult = document.getElementById("reconstructionResult");
                const themeToggleBtn = document.getElementById("themeToggleBtn");
                const qrModal = document.getElementById("qrModal");
                const qrCodeContainer = document.getElementById("qrCodeContainer");
                const toast = document.getElementById("toast");

                document.getElementById("currentYear").textContent = new Date().getFullYear();

                const showToast = (message) => {
                    toast.textContent = message;
                    toast.className = "show";
                    setTimeout(() => {
                        toast.className = toast.className.replace("show", "");
                    }, 3000);
                };

                const switchMode = (mode) => {
                    if (mode === "split") {
                        modeSplitBtn.classList.add("active");
                        modeReconstructBtn.classList.remove("active");
                        splitSection.classList.add("active");
                        reconstructSection.classList.remove("active");
                    } else {
                        modeSplitBtn.classList.remove("active");
                        modeReconstructBtn.classList.add("active");
                        splitSection.classList.remove("active");
                        reconstructSection.classList.add("active");
                    }
                };

                const showSplitError = (message) => {
                    splitError.textContent = message;
                    splitError.style.display = "block";
                };
                const hideSplitError = () => {
                    splitError.style.display = "none";
                };
                const showReconstructionResult = (message, type) => {
                    reconstructionResult.textContent = message;
                    reconstructionResult.className = `output-box ${type}`;
                    reconstructionResult.style.display = "block";
                };
                const hideReconstructionResult = () => {
                    reconstructionResult.style.display = "none";
                };

                const updateQueueUI = () => {
                    queueList.innerHTML = "";
                    const kValueForDisplay = sssInstance ? sssInstance.k : reconstructionQueue.length >= 2 ? "k?" : "?";
                    if (reconstructionQueue.length === 0) {
                        queueProgress.textContent = "請先產生或手動加入分割值";
                    } else {
                        queueProgress.textContent = `已選擇 ${reconstructionQueue.length} / ${kValueForDisplay} 份分割值`;
                    }
                    reconstructionQueue.forEach((share) => {
                        const item = document.createElement("div");
                        item.className = "queue-item";
                        const shareString = btoa(JSON.stringify(share));
                        item.innerHTML = `<span>ID: ${share.id} -> ${shareString.substring(0, 30)}...</span>`;
                        const removeBtn = document.createElement("button");
                        removeBtn.textContent = "移除";
                        removeBtn.onclick = () => {
                            reconstructionQueue = reconstructionQueue.filter((s) => s.id !== share.id);
                            updateQueueUI();
                        };
                        item.appendChild(removeBtn);
                        queueList.appendChild(item);
                    });
                    let canReconstruct = false;
                    if (sssInstance) {
                        canReconstruct = reconstructionQueue.length >= sssInstance.k;
                    } else {
                        canReconstruct = reconstructionQueue.length >= 2;
                    }
                    reconstructBtn.disabled = !canReconstruct;
                };

                const handleAddToQueue = (share) => {
                    if (reconstructionQueue.some((s) => s.id === share.id)) {
                        showToast(`ID 為 ${share.id} 的分割值已在佇列中。`);
                        return;
                    }
                    reconstructionQueue.push(share);
                    updateQueueUI();
                    switchMode("reconstruct");
                };

                const validateNK = () => {
                    const nStr = nInput.value;
                    const kStr = kInput.value;
                    let isValid = true;
                    kErrorMessage.textContent = "";
                    document.getElementById("nErrorMessage").textContent = "";

                    if (nStr === "" && kStr === "") {
                        generateBtn.disabled = true;
                        return false;
                    }
                    const n = parseInt(nStr);
                    const k = parseInt(kStr);

                    if (nStr === "" || isNaN(n) || n < 2 || n > 255) {
                        document.getElementById("nErrorMessage").textContent = "n 必須是 2 到 255 之間的數字";
                        isValid = false;
                    }
                    if (kStr === "" || isNaN(k) || k < 2 || k > 255) {
                        kErrorMessage.textContent = "k 必須是 2 到 255 之間的數字";
                        isValid = false;
                    }
                    if (isValid && k > n) {
                        kErrorMessage.textContent = "k (門檻值) 不能大於 n (總分割數)";
                        isValid = false;
                    }
                    generateBtn.disabled = !isValid;
                    return isValid;
                };

                nInput.addEventListener("input", validateNK);
                kInput.addEventListener("input", validateNK);
                modeSplitBtn.addEventListener("click", () => switchMode("split"));
                modeReconstructBtn.addEventListener("click", () => switchMode("reconstruct"));

                generateBtn.addEventListener("click", () => {
                    hideSplitError();
                    splitResultArea.style.display = "none";
                    splitResultTableBody.innerHTML = "";
                    try {
                        const secret = originalString.value;
                        const n = parseInt(nInput.value);
                        const k = parseInt(kInput.value);
                        if (!secret && secret !== "") throw new Error("原始字串不能為空 (除非刻意要分享空字串)。"); // Allow empty string
                        if (!nInput.value || !kInput.value) throw new Error("n 和 k 皆必須填寫。");
                        if (!validateNK()) {
                            showSplitError("請修正 n 或 k 的錯誤。");
                            return;
                        }

                        sssInstance = new ShamirSecretsAdapter(secret, n, k);
                        const shares = sssInstance.generateShares();
                        shares.forEach((share) => {
                            const row = splitResultTableBody.insertRow();
                            const base64Share = btoa(JSON.stringify(share));
                            row.insertCell(0).textContent = share.id;
                            row.insertCell(1).textContent = base64Share;
                            const actionCell = row.insertCell(2);
                            const container = document.createElement("div");
                            container.className = "action-button-container";
                            const addBtn = document.createElement("button");
                            addBtn.textContent = "加入";
                            addBtn.title = "加入重建佇列";
                            addBtn.className = "action-btn";
                            addBtn.onclick = () => handleAddToQueue(share);
                            const copyBtn = document.createElement("button");
                            copyBtn.textContent = "複製";
                            copyBtn.title = "複製 Base64 分割值";
                            copyBtn.className = "action-btn secondary";
                            copyBtn.onclick = () => {
                                navigator.clipboard
                                    .writeText(base64Share)
                                    .then(() => showToast(`ID ${share.id} 的分割值已複製！`))
                                    .catch((err) => showToast("複製失敗: " + err));
                            };
                            const qrBtn = document.createElement("button");
                            qrBtn.textContent = "QR";
                            qrBtn.title = "產生此分割值的 QR Code";
                            qrBtn.className = "action-btn qr";
                            qrBtn.onclick = () => {
                                qrCodeContainer.innerHTML = "";
                                if (typeof QRCode !== "undefined") {
                                    new QRCode(qrCodeContainer, {
                                        text: base64Share,
                                        width: 256,
                                        height: 256,
                                        colorDark:
                                            document.documentElement.getAttribute("data-theme") === "dark"
                                                ? "#e8e8f0"
                                                : "#000000",
                                        colorLight:
                                            document.documentElement.getAttribute("data-theme") === "dark"
                                                ? "#2f2f4f"
                                                : "#ffffff",
                                        correctLevel: QRCode.CorrectLevel.M,
                                    });
                                    qrModal.style.display = "flex";
                                } else {
                                    showSplitError("QR Code 函式庫載入失敗。");
                                }
                            };
                            container.appendChild(addBtn);
                            container.appendChild(copyBtn);
                            container.appendChild(qrBtn);
                            actionCell.appendChild(container);
                        });
                        splitResultArea.style.display = "block";
                        reconstructionQueue = [];
                        updateQueueUI();
                    } catch (e) {
                        console.error("Generate Error:", e);
                        showSplitError(`錯誤: ${e.message}`);
                    }
                });

                clearSplitBtn.addEventListener("click", () => {
                    originalString.value = "";
                    nInput.value = "";
                    kInput.value = "";
                    kErrorMessage.textContent = "";
                    document.getElementById("nErrorMessage").textContent = "";
                    hideSplitError();
                    splitResultArea.style.display = "none";
                    splitResultTableBody.innerHTML = "";
                    sssInstance = null;
                    reconstructionQueue = [];
                    updateQueueUI();
                    validateNK();
                });

                addCustomShareBtn.addEventListener("click", () => {
                    hideReconstructionResult();
                    try {
                        const base64Text = customShareInput.value.trim();
                        if (!base64Text) throw new Error("輸入不能為空。");
                        const jsonText = atob(base64Text);
                        const share = JSON.parse(jsonText);
                        if (typeof share.id !== "number" || !Array.isArray(share.value)) {
                            throw new Error("Base64 解碼後的格式不正確，缺少 id 或 value (必須是陣列) 欄位。");
                        }
                        if (!share.value.every((val) => typeof val === "number" && val >= 0 && val <= 255)) {
                            throw new Error("分割值中的 value 陣列包含無效的數字 (應為 0-255 之間的數字)。");
                        }
                        if (!sssInstance && reconstructionQueue.length === 0) {
                            showToast("提示：重建參數 (n,k) 未知，請確保加入足夠且正確的分割值。");
                        }
                        handleAddToQueue(share);
                        customShareInput.value = "";
                    } catch (e) {
                        console.error("Add Custom Share Error:", e);
                        showReconstructionResult(`加入失敗: ${e.message}`, "error");
                    }
                });

                clearQueueBtn.addEventListener("click", () => {
                    reconstructionQueue = [];
                    hideReconstructionResult();
                    updateQueueUI();
                });

                reconstructBtn.addEventListener("click", () => {
                    try {
                        if (reconstructionQueue.length === 0) throw new Error("重建佇列是空的。請加入分割值。");

                        // If sssInstance is not set (e.g. user only pastes shares),
                        // we need to create a temporary one. For this, we need k.
                        // We'll try to infer k from nInput and kInput if they are set and valid,
                        // otherwise, we can't reliably reconstruct.
                        let currentK = sssInstance ? sssInstance.k : parseInt(kInput.value);
                        let currentN = sssInstance ? sssInstance.n : parseInt(nInput.value);

                        if (isNaN(currentK) || currentK < 2) {
                            throw new Error(
                                "錯誤：無法確定重建所需的門檻值 (k)。請先在「分割」頁面設定 n 和 k，或確保手動輸入的 k 值有效。"
                            );
                        }
                        if (reconstructionQueue.length < currentK) {
                            throw new Error(`需要 ${currentK} 份分割值，目前只有 ${reconstructionQueue.length} 份。`);
                        }

                        let tempSssInstance = sssInstance;
                        if (!tempSssInstance) {
                            // Create a temporary instance. Need N for constructor validation.
                            // If N is not available or invalid, we cannot proceed safely.
                            if (isNaN(currentN) || currentN < currentK || currentN > 255) {
                                throw new Error("錯誤：無法確定總分割數 (n) 以進行重建。請在「分割」頁面設定 n。");
                            }
                            // A dummy secret is needed for the constructor, it won't be used for reconstruction itself.
                            tempSssInstance = new ShamirSecretsAdapter("temp", currentN, currentK);
                        }

                        const validQueue = reconstructionQueue
                            .map((s) => {
                                if (
                                    !Array.isArray(s.value) ||
                                    !s.value.every((val) => typeof val === "number" && val >= 0 && val <= 255)
                                ) {
                                    throw new Error(`佇列中的分割值 ID ${s.id} 格式或內容無效。`);
                                }
                                return s;
                            })
                            .slice(0, currentK); // Use only k shares

                        const reconstructedSecret = tempSssInstance.reconstructSecret(validQueue);
                        showReconstructionResult(reconstructedSecret, "success");
                    } catch (e) {
                        console.error("Reconstruct Error:", e);
                        showReconstructionResult(`重建失敗: ${e.message}`, "error");
                    }
                });

                qrModal.addEventListener("click", (event) => {
                    if (event.target === qrModal) qrModal.style.display = "none";
                });

                const applyTheme = (theme) => {
                    document.documentElement.setAttribute("data-theme", theme);
                    themeToggleBtn.textContent = theme === "dark" ? "☀️" : "🌙";
                    localStorage.setItem(THEME_KEY, theme); // Changed key
                };
                themeToggleBtn.addEventListener("click", () => {
                    const newTheme = document.documentElement.getAttribute("data-theme") === "dark" ? "light" : "dark";
                    applyTheme(newTheme);
                });
                applyTheme(localStorage.getItem(THEME_KEY) || "dark");

                validateNK();
                updateQueueUI();
            });
        </script>
    </body>
</html>
