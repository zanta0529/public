<!DOCTYPE html>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>助記詞管理工具 (ChaCha20-Poly1305)</title>
        <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
        <style>
            :root {
                --bg-main: #1e1e2f;
                --bg-card: #2f2f4f;
                --primary: #5865f2;
                --primary-hover: #4752c4;
                --secondary: #b9bbbe;
                --input-bg: #444;
                --text-color: #e8e8f0;
                --border-color: #4a4a5f;
                --error-color: #ff7f7f;
                --error-bg: #4f2e2e;
                --success-color: #60d978;
                --success-bg: #2a4a30;
                --button-reset-bg: #da373c;
                --button-reset-hover-bg: #a1282c;
            }
            body {
                background: var(--bg-main);
                color: var(--text-color);
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
                padding: 1rem;
                line-height: 1.6;
            }
            .card {
                background: var(--bg-card);
                padding: 2rem;
                border-radius: 8px;
                max-width: 80%;
                margin: auto;
                border: 1px solid var(--border-color);
            }
            .card h1 {
                text-align: center;
                margin-top: 0;
                margin-bottom: 2rem;
            }
            .field {
                margin-bottom: 1.5rem;
            }
            label {
                display: block;
                margin-bottom: 0.5rem;
                font-weight: 600;
                color: var(--secondary);
            }
            input,
            textarea,
            button {
                width: 100%;
                padding: 0.75rem;
                background: var(--input-bg);
                border: 1px solid var(--border-color);
                border-radius: 5px;
                color: var(--text-color);
                box-sizing: border-box;
                font-size: 1rem;
                transition: background-color 0.2s, border-color 0.2s;
            }
            input:focus,
            textarea:focus {
                outline: none;
                border-color: var(--primary);
            }
            button {
                cursor: pointer;
                background: var(--primary);
                font-weight: 600;
                border: none;
            }
            button:hover {
                background: var(--primary-hover);
            }
            .output-container {
                margin-top: 1.5rem;
            }
            .output {
                padding: 1rem;
                border-radius: 5px;
                min-height: 50px;
                white-space: pre-wrap;
                word-break: break-all;
                font-size: 1.1em;
                line-height: 1.5;
                border-left: 5px solid transparent;
                background-color: var(--input-bg);
                transition: background-color 0.3s, border-color 0.3s;
            }
            .output.success {
                color: var(--success-color);
                background-color: var(--success-bg);
                border-left-color: var(--success-color);
            }
            .output.error {
                color: var(--error-color);
                background-color: var(--error-bg);
                border-left-color: var(--error-color);
            }
            #jsonView {
                margin-top: 1rem;
                padding: 1rem;
                background: var(--input-bg);
                border: 1px solid var(--border-color);
                border-radius: 5px;
                white-space: pre-wrap;
                word-break: break-all;
                display: none;
            }
            .action-button-group {
                display: flex;
                gap: 1rem;
            }
            #resetBtn {
                background-color: var(--button-reset-bg);
            }
            #resetBtn:hover {
                background-color: var(--button-reset-hover-bg);
            }
            .output-copy-button {
                margin-top: 1rem;
            }
            .output-copy-button:hover {
                filter: brightness(110%);
            }
            footer {
                text-align: center;
                margin-top: 30px;
                font-size: 0.9em;
                color: var(--secondary);
            }
        </style>
    </head>
    <body>
        <div class="card">
            <h1>助記詞管理工具 (ChaCha20-Poly1305)</h1>
            <div class="field">
                <label for="mnemonic">助記詞或明文 (Plain-Text)</label>
                <textarea id="mnemonic" rows="4" placeholder="輸入助記詞"></textarea>
            </div>
            <div class="field">
                <label for="passphrase">密碼短語 (Passphrase)</label>
                <input id="passphrase" type="password" placeholder="輸入密碼短語" />
            </div>
            <div class="field">
                <button id="encryptBtn">加密並產生 QR Code</button>
            </div>
            <canvas
                id="qrCanvas"
                width="256"
                height="256"
                style="display: none; margin: auto; border-radius: 8px"
            ></canvas>
            <div id="jsonView"></div>
            <div class="field">
                <label for="base64json">密文 (Base64 JSON)</label>
                <textarea id="base64json" rows="6" placeholder="加密後之 Base64 JSON 將顯示於此"></textarea>
            </div>
            <div class="field">
                <button id="decryptBtn">解密</button>
            </div>
            <div class="field action-button-group">
                <button id="copyBtn" style="flex: 1">複製密文</button>
                <button id="pasteBtn" style="flex: 1">貼上密文</button>
                <button id="resetBtn" style="flex: 1">重設</button>
            </div>
            <div class="output-container">
                <div id="output" class="output">點擊按鈕開始操作...</div>
                <button id="copyDecryptedBtn" class="output-copy-button" style="display: none">複製解密結果</button>
            </div>
        </div>
        <footer>
            <p>&copy; <span id="currentYear"></span> Zanta's Customized ChaCha20 Tool for Cryptocurrency Wallets</p>
        </footer>

        <script type="module">
            // 匯入 noble-ciphers 函式庫
            import { chacha20poly1305 } from "https://cdn.jsdelivr.net/npm/@noble/ciphers/esm/chacha.js";

            // 定義加密參數
            const SALT_BYTES = 16;
            const NONCE_BYTES = 12; // ChaCha20-Poly1305 標準使用 12 位元組 (96位元) 的 Nonce
            const DEFAULT_ITERATIONS = 300000;
            const KEY_LENGTH_BITS = 256; // ChaCha20 固定使用 256位元 (32位元組) 金鑰

            document.getElementById("currentYear").textContent = new Date().getFullYear();

            // 工具函式：簡化 DOM 存取
            function getObject(id) {
                return document.getElementById(id);
            }

            // 工具函式：設定輸出訊息
            function setOutput(type, message) {
                const outputDiv = getObject("output");
                outputDiv.textContent = message;
                outputDiv.className = `output ${type}`;
                getObject("copyDecryptedBtn").style.display = "none";
            }

            // 工具函式： Uint8Array 轉 Base64
            function toBase64(uint8array) {
                return btoa(String.fromCharCode.apply(null, uint8array));
            }

            // 工具函式： Base64 轉 Uint8Array
            function fromBase64(base64) {
                return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
            }

            // 核心函式：加密
            async function encrypt() {
                const mnemonic = getObject("mnemonic").value.trim();
                const passphrase = getObject("passphrase").value;
                const jsonView = getObject("jsonView");

                jsonView.style.display = "none";

                if (!mnemonic || !passphrase) {
                    setOutput("error", "錯誤：助記詞和密碼短語不能為空。");
                    return;
                }

                try {
                    const enc = new TextEncoder();
                    const nonce = crypto.getRandomValues(new Uint8Array(NONCE_BYTES));
                    const salt = crypto.getRandomValues(new Uint8Array(SALT_BYTES));

                    // 1. 使用 PBKDF2 從密碼短語衍生金鑰
                    const keyMaterial = await crypto.subtle.importKey(
                        "raw",
                        enc.encode(passphrase),
                        { name: "PBKDF2" },
                        false,
                        ["deriveBits"]
                    );

                    // 使用 deriveBits 產生指定長度的原始金鑰位元
                    const keyBytes = new Uint8Array(
                        await crypto.subtle.deriveBits(
                            { name: "PBKDF2", salt, iterations: DEFAULT_ITERATIONS, hash: "SHA-256" },
                            keyMaterial,
                            KEY_LENGTH_BITS
                        )
                    );

                    // 2. 使用 noble-ciphers 進行加密
                    const plaintextBytes = enc.encode(mnemonic);
                    const aead = chacha20poly1305(keyBytes, nonce); // 此工具不需AAD，故省略
                    const ciphertextWithTag = aead.encrypt(plaintextBytes); // 函式庫會自動合併密文與Tag

                    // 3. 準備輸出的 JSON 物件
                    const json = {
                        salt: toBase64(salt),
                        iterations: DEFAULT_ITERATIONS,
                        nonce: toBase64(nonce), // Nonce 取代 IV
                        ciphertext: toBase64(ciphertextWithTag), // 合併後的密文
                        algorithm: {
                            name: "ChaCha20-Poly1305",
                            keyDerivation: { name: "PBKDF2", hash: "SHA-256" },
                        },
                    };

                    const outputBase64 = btoa(JSON.stringify(json));
                    getObject("qrCanvas").style.display = "block";
                    QRCode.toCanvas(getObject("qrCanvas"), outputBase64, { errorCorrectionLevel: "H", width: 256 });
                    getObject("base64json").value = outputBase64;
                    jsonView.textContent = JSON.stringify(json, null, 2);
                    jsonView.style.display = "block";
                    setOutput("success", "✅ 加密成功！QR Code 與 Base64 密文已產生。");
                } catch (e) {
                    console.error("加密失敗:", e);
                    setOutput("error", `❌ 加密失敗：${e.message}`);
                }
            }

            // 核心函式：解密
            async function decrypt() {
                const passphrase = getObject("passphrase").value;
                const base64json = getObject("base64json").value.trim();

                if (!passphrase || !base64json) {
                    setOutput("error", "錯誤：密文與密碼短語不能為空。");
                    return;
                }

                try {
                    const jsonString = atob(base64json);
                    const json = JSON.parse(jsonString);

                    // 驗證演算法是否相符
                    if (json.algorithm?.name !== "ChaCha20-Poly1305") {
                        throw new Error("密文格式不符，預期演算法為 ChaCha20-Poly1305。");
                    }

                    const salt = fromBase64(json.salt);
                    const nonce = fromBase64(json.nonce);
                    const ciphertextWithTag = fromBase64(json.ciphertext);
                    const iterations = json.iterations;

                    if (typeof iterations !== "number" || iterations <= 0)
                        throw new Error("JSON 中的 iterations 數值無效。");

                    // 1. 再次使用 PBKDF2 從密碼短語衍生出相同的金鑰
                    const keyMaterial = await crypto.subtle.importKey(
                        "raw",
                        new TextEncoder().encode(passphrase),
                        { name: "PBKDF2" },
                        false,
                        ["deriveBits"]
                    );
                    const keyBytes = new Uint8Array(
                        await crypto.subtle.deriveBits(
                            { name: "PBKDF2", salt, iterations, hash: "SHA-256" },
                            keyMaterial,
                            KEY_LENGTH_BITS
                        )
                    );

                    // 2. 使用 noble-ciphers 進行解密
                    const aead = chacha20poly1305(keyBytes, nonce);
                    const decryptedBytes = aead.decrypt(ciphertextWithTag); // 函式庫會自動驗證 Tag
                    const decryptedResult = new TextDecoder().decode(decryptedBytes);

                    // 3. 顯示解密結果
                    setOutput("success", `✅ 成功解密！\n\n${decryptedResult}`);

                    const copyDecryptedBtn = getObject("copyDecryptedBtn");
                    copyDecryptedBtn.dataset.decryptedText = decryptedResult;
                    copyDecryptedBtn.style.display = "block";
                } catch (e) {
                    console.error("解密失敗:", e);
                    // 檢查是否為認證失敗
                    if (e.message?.includes("MAC") || e.message?.includes("tag")) {
                        setOutput("error", "❌ 解密失敗：密碼短語不正確，或密文已被竄改。");
                    } else {
                        setOutput("error", `❌ 解密失敗：${e.message}`);
                    }
                }
            }

            // --- 以下為 UI 輔助函式，邏輯不變 ---
            function copyCipher() {
                const text = getObject("base64json").value;
                if (!text) {
                    setOutput("error", "錯誤：沒有可複製的密文。");
                    return;
                }
                navigator.clipboard
                    .writeText(text)
                    .then(() => setOutput("success", "✅ 已複製密文至剪貼簿。"))
                    .catch((err) => {
                        console.error("複製失敗:", err);
                        setOutput("error", `❌ 複製失敗: ${err.message}`);
                    });
            }

            function pasteCipher() {
                navigator.clipboard
                    .readText()
                    .then((text) => {
                        getObject("base64json").value = text;
                        setOutput("success", "✅ 已貼上剪貼簿內容。");
                    })
                    .catch((err) => {
                        console.error("貼上失敗:", err);
                        setOutput("error", `❌ 貼上失敗: ${err.message}. 瀏覽器可能不支援或未授權。`);
                    });
            }

            function copyDecrypted() {
                const decryptedText = getObject("copyDecryptedBtn").dataset.decryptedText;
                navigator.clipboard
                    .writeText(decryptedText)
                    .then(() => setOutput("success", "✅ 已複製解密結果到剪貼簿。"))
                    .catch((err) => {
                        console.error("複製解密結果失敗:", err);
                        setOutput("error", `❌ 複製解密結果失敗: ${err.message}`);
                    });
            }

            function resetAll() {
                ["mnemonic", "passphrase", "base64json"].forEach((id) => (getObject(id).value = ""));
                const canvas = getObject("qrCanvas");
                canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height);
                canvas.style.display = "none";
                getObject("jsonView").style.display = "none";
                setOutput("", "點擊按鈕開始操作...");
                navigator.clipboard.writeText("").catch((err) => console.error("清除剪貼簿失敗", err));
            }

            function init() {
                getObject("encryptBtn").addEventListener("click", encrypt);
                getObject("decryptBtn").addEventListener("click", decrypt);
                getObject("copyBtn").addEventListener("click", copyCipher);
                getObject("pasteBtn").addEventListener("click", pasteCipher);
                getObject("resetBtn").addEventListener("click", resetAll);
                getObject("copyDecryptedBtn").addEventListener("click", copyDecrypted);
            }

            document.addEventListener("DOMContentLoaded", init);
        </script>
    </body>
</html>
