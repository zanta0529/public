import{b as x,L as f,d as u,a as g,h as y,e as S}from"./index-C3BDOTSv.js";function m(s,t={}){const{maxLength:a=null,allowNewlines:n=!0,trim:r=!0}=t;if(!s||typeof s!="string")return"";let e=s;return e=e.replace(/<[^>]*>/g,""),e=e.replace(/\0/g,""),e=e.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g,""),n?e=e.replace(/[^\S\n]+/g," "):e=e.replace(/\s+/g," "),r&&(e=e.trim()),a&&e.length>a&&(e=e.substring(0,a)),e}function v(s){const t=[],a=m(s.word,{maxLength:f.WORD_MAX_LENGTH,allowNewlines:!1});a?a.length<1&&t.push("Word cannot be empty"):t.push("Word is required");const n=m(s.definition,{maxLength:f.DEFINITION_MAX_LENGTH});n?n.length<3&&t.push("Definition is too short (minimum 3 characters)"):t.push("Definition is required");const r=m(s.context,{maxLength:f.CONTEXT_MAX_LENGTH}),e=m(s.translation,{maxLength:f.DEFINITION_MAX_LENGTH}),o=m(s.ipa,{maxLength:100,allowNewlines:!1});let i=[];if(Array.isArray(s.collocations)&&(i=s.collocations.map(d=>m(d,{maxLength:f.COLLOCATIONS_ITEM_MAX,allowNewlines:!1})).filter(Boolean).slice(0,f.COLLOCATIONS_MAX)),t.length>0)throw x(`Validation failed: ${t.join(", ")}`,{errors:t,originalData:s});return{word:a,definition:n,context:r,translation:e,ipa:o,collocations:i}}function A(s){if(!s||typeof s!="string")throw x("Invalid JSON input");try{return JSON.parse(s)}catch(t){throw x("Invalid JSON format: "+t.message,{originalError:t.message})}}class D{_generateId(){const t=Date.now(),a=Math.random().toString(36).substring(2,8);return`${t}_${a}`}_isContextSimilar(t,a){if(!t||!a)return!1;const n=o=>o.toLowerCase().replace(/[^\w\s]|_/g,"").replace(/\s+/g," ").trim(),r=n(t),e=n(a);return r===e||r.includes(e)||e.includes(r)}async importCards(t,a={}){try{const{smartDeduplication:n=!1}=a,r=A(t);if(!Array.isArray(r))throw new Error("Input must be a JSON array");const e=[];let o=0;const i=[];for(let d=0;d<r.length;d++){const l=r[d];try{const c=v(l),w=c.word.trim(),h=await u.vocab.where("word").equals(w).toArray();let p=!1;if(h.length>0)for(const C of h){if(this._isContextSimilar(c.context,C.context)){p=!0;break}if(n&&await g.checkSemanticSimilarity(w,C.context,c.context)){p=!0;break}}p?o++:e.push({...c,word:w,id:this._generateId(),status:"new",reviewCount:0,nextReview:Date.now(),easeFactor:2.5,interval:0,updatedAt:Date.now(),createdAt:Date.now()})}catch(c){i.push({index:d,word:l?.word||"unknown",error:c.message}),o++}}return e.length>0&&await u.vocab.bulkAdd(e),{addedCount:e.length,skippedCount:o,errors:i.length>0?i:void 0}}catch(n){const r=y(n,"importCards");throw new Error(r.userMessage)}}async addCard(t,a={}){try{const{smartDeduplication:n=!1}=a,r=v(t),e=r.word.trim(),o=await u.vocab.where("word").equals(e).toArray();if(o.find(l=>this._isContextSimilar(r.context,l.context)))throw new Error(`Duplicate card: "${e}" with similar context already exists.`);if(n&&o.length>0){for(const l of o)if(await g.checkSemanticSimilarity(e,l.context,r.context))throw new Error(`Duplicate card (Semantic): "${e}" has a semantically identical context already.`)}const d={...r,word:e,id:this._generateId(),status:"new",reviewCount:0,nextReview:Date.now(),easeFactor:2.5,interval:0,updatedAt:Date.now(),createdAt:Date.now()};return await u.vocab.add(d),d}catch(n){const r=y(n,"addCard");throw new Error(r.userMessage)}}async scanForDuplicates(t={}){const{smartDeduplication:a=!1}=t,n=await u.vocab.toArray(),r=[],e={};for(const o of n){const i=o.word.trim().toLowerCase();e[i]||(e[i]=[]),e[i].push(o)}for(const o in e){const i=e[o];if(i.length<2)continue;i.sort((l,c)=>c.reviewCount!==l.reviewCount?c.reviewCount-l.reviewCount:l.createdAt-c.createdAt);const d=[i[0]];for(let l=1;l<i.length;l++){const c=i[l];let w=!1;for(const h of d){if(this._isContextSimilar(c.context,h.context)){w=!0;break}if(a&&await g.checkSemanticSimilarity(c.word,h.context,c.context)){w=!0;break}}w?r.push(c.id):d.push(c)}}return r}async bulkDeleteCards(t){!t||t.length===0||await u.vocab.bulkDelete(t)}async updateCard(t){const a={...t,updatedAt:Date.now()};return await u.vocab.put(a),a}async deleteCard(t){await u.vocab.delete(t)}async getAllCards(){return await u.vocab.toArray()}async clearAllCards(){await u.vocab.clear()}async getDueCards(t=20){const a=Date.now();return(await u.vocab.where("nextReview").belowOrEqual(a).and(r=>r.status!=="new").toArray()).sort((r,e)=>{const o=r.easeFactor||2.5,i=e.easeFactor||2.5;return o!==i?o-i:r.nextReview-e.nextReview}).slice(0,t)}async processReview(t,a){const n=S(t,a),r={...t,...n};await this.updateCard(r);try{await u.study_logs.add({cardId:r.id,grade:Number(a),reviewTime:Date.now(),easeFactor:r.easeFactor,interval:r.interval})}catch(e){console.warn("Failed to save study log",e)}return r}}const _=new D;export{_ as c};
