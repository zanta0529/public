<!DOCTYPE html>
<html lang="zh-Hant" data-theme="dark">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>進階版純文字加密、解密器</title>
        <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
        <style>
            :root {
                --primary-color: #f59e0b;
                --primary-hover-color: #d97706;
                --secondary-color: #6b7280;
                --secondary-hover-color: #4b5563;
                --success-color: #059669;
                --success-bg: #d1fae5;
                --error-color: #dc2626;
                --error-bg: #fee2e2;
                --info-color: #0891b2;
                --info-bg: #cffafe;
                --note-color: #92400e;
                --note-bg: #fefce8;
                --section-header-bg: #f3f4f6;
                --bg-color: #f9fafb;
                --container-bg: #ffffff;
                --text-color: #1f2937;
                --border-color: #e5e7eb;
                --input-bg: #ffffff;
                --input-focus-shadow: rgba(245, 158, 11, 0.25);
                --button-disabled-bg: #d1d5db;
                --button-danger-bg: #b91c1c;
                --button-danger-hover-bg: #ef4444;
                --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
                --toast-bg: #1f2937;
                --toast-color: #f9fafb;
            }
            :root[data-theme="dark"] {
                --primary-color: #f59e0b;
                --primary-hover-color: #fbbf24;
                --secondary-color: #9ca3af;
                --secondary-hover-color: #d1d5db;
                --success-color: #6ee7b7;
                --success-bg: #064e3b;
                --error-color: #f87171;
                --error-bg: #7f1d1d;
                --info-color: #67e8f9;
                --info-bg: #164e63;
                --note-color: #fde047;
                --note-bg: #451a03;
                --section-header-bg: rgba(255, 255, 255, 0.05);
                --bg-color: #111827;
                --container-bg: #1f2937;
                --text-color: #d1d5db;
                --border-color: #374151;
                --input-bg: #374151;
                --input-focus-shadow: rgba(245, 158, 11, 0.3);
                --button-disabled-bg: #4b5563;
                --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
                --toast-bg: #fde68a;
                --toast-color: #78350f;
            }
            *,
            *::before,
            *::after {
                box-sizing: border-box;
            }
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                margin: 0;
                padding: 2rem;
                background-color: var(--bg-color);
                color: var(--text-color);
                line-height: 1.6;
                display: flex;
                flex-direction: column;
                align-items: center;
                min-height: 100vh;
                transition: background-color 0.3s, color 0.3s;
            }
            .container {
                background-color: transparent;
                padding: 0;
                border: none;
                box-shadow: none;
                width: 100%;
                max-width: 800px;
            }
            h1 {
                text-align: center;
                margin-bottom: 2.5rem;
            }
            label {
                font-weight: 600;
                display: block;
                margin-bottom: 0.5rem;
            }
            .form-group {
                margin-bottom: 1.5rem;
            }
            .card {
                border: 1px solid var(--border-color);
                border-radius: 12px;
                background-color: var(--container-bg);
                box-shadow: var(--box-shadow);
                transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
                overflow: hidden;
            }
            .card-content {
                padding: 1.5rem;
            }
            .button-group {
                display: flex;
                flex-wrap: wrap;
                gap: 1rem;
                align-items: center;
            }
            button,
            .button {
                display: inline-block;
                padding: 0.75rem 1.5rem;
                background-color: var(--primary-color);
                color: #422006;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1em;
                font-weight: 600;
                text-decoration: none;
                text-align: center;
                transition: background-color 0.3s, transform 0.1s;
                width: 100%;
            }
            button:hover:not(:disabled) {
                background-color: var(--primary-hover-color);
                transform: translateY(-1px);
            }
            button.secondary {
                background-color: var(--secondary-color);
                color: var(--text-color);
            }
            :root[data-theme="dark"] button.secondary {
                color: var(--bg-color);
            }
            button.secondary:hover:not(:disabled) {
                background-color: var(--secondary-hover-color);
            }
            button.danger {
                background-color: var(--button-danger-bg);
                color: white;
            }
            button.danger:hover:not(:disabled) {
                background-color: var(--button-danger-hover-bg);
            }
            button:disabled {
                background-color: var(--button-disabled-bg);
                cursor: not-allowed;
                opacity: 0.7;
            }
            input[type="text"],
            input[type="password"],
            textarea {
                width: 100%;
                padding: 0.75rem;
                border: 1px solid var(--border-color);
                border-radius: 5px;
                font-size: 1em;
                background-color: var(--input-bg);
                color: var(--text-color);
                transition: border-color 0.3s, box-shadow 0.3s;
            }
            input[type="text"]:focus,
            input[type="password"]:focus,
            textarea:focus {
                outline: none;
                border-color: var(--primary-color);
                box-shadow: 0 0 0 0.2rem var(--input-focus-shadow);
            }
            textarea {
                min-height: 120px;
                resize: vertical;
            }
            .option-group {
                display: flex;
                flex-wrap: wrap;
                gap: 0;
                margin-bottom: 1.5rem;
                border: 1px solid var(--border-color);
                border-radius: 5px;
                overflow: hidden;
            }
            .option {
                padding: 10px 15px;
                cursor: pointer;
                transition: background-color 0.3s, color 0.3s;
                flex-grow: 1;
                text-align: center;
                border-right: 1px solid var(--border-color);
            }
            .option:last-child {
                border-right: none;
            }
            .option.selected {
                background-color: var(--primary-color);
                color: #422006;
                font-weight: bold;
            }
            .hint-note {
                font-size: 0.9em;
                color: var(--note-color);
                background-color: var(--note-bg);
                padding: 0.75rem 1rem;
                border-radius: 5px;
                margin-top: 1rem;
                border-left: 4px solid var(--note-color);
            }
            .output-box {
                padding: 1rem;
                border-radius: 5px;
                white-space: pre-wrap;
                word-break: break-all;
                border-left: 5px solid;
                margin-top: 1.5rem;
            }
            .output-box.success {
                color: var(--success-color);
                border-color: var(--success-color);
                background-color: var(--success-bg);
            }
            .output-box.error {
                color: var(--error-color);
                border-color: var(--error-color);
                background-color: var(--error-bg);
            }
            .output-box.info {
                color: var(--info-color);
                border-color: var(--info-color);
                background-color: var(--info-bg);
            }
            footer {
                text-align: center;
                margin-top: auto;
                padding-top: 2rem;
                font-size: 0.9em;
                color: var(--secondary-color);
            }
            #themeToggleBtn {
                background: none;
                border: 1px solid var(--border-color);
                color: var(--text-color);
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1.2em;
                margin-left: 10px;
                vertical-align: middle;
                transition: 0.3s;
            }
            #themeToggleBtn:hover {
                background-color: var(--border-color);
            }
            #toast {
                visibility: hidden;
                opacity: 0;
                min-width: 250px;
                background-color: var(--toast-bg);
                color: var(--toast-color);
                text-align: center;
                border-radius: 5px;
                padding: 16px;
                position: fixed;
                z-index: 1001;
                left: 50%;
                transform: translateX(-50%);
                bottom: 30px;
                font-size: 17px;
                transition: opacity 0.5s, visibility 0.5s, bottom 0.5s;
            }
            #toast.show {
                visibility: visible;
                opacity: 1;
            }
            .password-wrapper {
                position: relative;
                display: flex;
                align-items: center;
            }
            .toggle-password-icon {
                position: absolute;
                right: 12px;
                cursor: pointer;
                color: var(--secondary-color);
                transition: color 0.2s;
            }
            #passphrase {
                padding-right: 40px;
            }
            .results-area {
                margin-top: 1.5rem;
                text-align: center;
            }
            #qrCanvas {
                border-radius: 8px;
                border: 1px solid var(--border-color);
            }
            #jsonView,
            #base64ResultView {
                margin-top: 1rem;
                padding: 1rem;
                background: var(--input-bg);
                border: 1px solid var(--border-color);
                border-radius: 5px;
                white-space: pre-wrap;
                word-break: break-all;
                text-align: left;
            }
            #params-display-area {
                background-color: var(--section-header-bg);
                border: 1px solid var(--border-color);
                border-radius: 5px;
                padding: 1rem;
                margin-top: 1.5rem;
            }
            #params-display-area p {
                margin: 0.5rem 0;
            }
            #params-display-area p > span {
                font-weight: bold;
                color: var(--primary-color);
            }
            [hidden] {
                display: none !important;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <header>
                <h1>進階版純文字加密、解密器</h1>
            </header>
            <main>
                <section class="card">
                    <div class="card-content">
                        <div id="modeSelector" class="option-group">
                            <div class="option selected" data-mode="encrypt">加密模式</div>
                            <div class="option" data-mode="decrypt">解密模式</div>
                        </div>

                        <div id="encrypt-section">
                            <div class="form-group">
                                <label for="mnemonic">明文 (Plain-Text)</label>
                                <textarea id="mnemonic" rows="4" placeholder="在此輸入要加密的文字"></textarea>
                            </div>
                            <div class="form-group">
                                <label>加密演算法</label>
                                <div id="algoSelectionGroup" class="option-group">
                                    <div
                                        class="option selected"
                                        data-value="AES-GCM"
                                        title="AES-GCM (Advanced Encryption Standard - Galois/Counter Mode)"
                                    >
                                        AES-GCM
                                    </div>
                                    <div
                                        class="option"
                                        data-value="ChaCha20-Poly1305"
                                        title="ChaCha20-Poly1305 (Stream Cipher with Poly1305 Authentication)"
                                    >
                                        ChaCha20-Poly1305
                                    </div>
                                </div>
                                <div class="hint-note" style="margin-top: 0">
                                    💡 註：僅「加密」模式才須指定演算法，「解密」模式時由工具自動偵測演算法並進行解密。
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="passphrase-encrypt">密碼短語 (Passphrase)</label>
                                <div class="password-wrapper">
                                    <input id="passphrase-encrypt" type="password" placeholder="輸入密碼短語" />
                                    <span
                                        id="togglePasswordEncrypt"
                                        class="toggle-password-icon"
                                        title="顯示/隱藏密碼"
                                    ></span>
                                </div>
                            </div>
                            <div class="form-group"><button id="encryptBtn">執行加密</button></div>
                        </div>

                        <div id="decrypt-section" hidden>
                            <div class="form-group">
                                <label for="base64json">密文 (Base64 JSON)</label>
                                <textarea
                                    id="base64json"
                                    rows="6"
                                    placeholder="在此貼上加密後的 Base64 JSON 密文"
                                ></textarea>
                            </div>
                            <div class="form-group">
                                <button id="parseBtn" class="secondary">解析參數 (可選)</button>
                            </div>
                            <div id="params-display-area" hidden></div>
                            <div class="form-group">
                                <label for="passphrase-decrypt">密碼短語 (Passphrase)</label>
                                <div class="password-wrapper">
                                    <input id="passphrase-decrypt" type="password" placeholder="輸入解密用的密碼短語" />
                                    <span
                                        id="togglePasswordDecrypt"
                                        class="toggle-password-icon"
                                        title="顯示/隱藏密碼"
                                    ></span>
                                </div>
                            </div>
                            <div class="form-group">
                                <button id="decryptBtn">開始解密</button>
                            </div>
                        </div>

                        <div class="button-group" style="justify-content: space-between">
                            <button id="pasteBtn" class="secondary" style="flex: 1" hidden>貼上密文</button>
                            <button id="copyBtn" class="secondary" style="flex: 1" hidden>複製</button>
                            <button id="resetBtn" class="danger" style="flex: 1">全部重設</button>
                        </div>

                        <div id="results-area" class="results-area" hidden>
                            <div id="output" class="output-box info">...</div>
                            <canvas id="qrCanvas" width="256" height="256" style="margin-top: 1.5rem"></canvas>
                            <div id="jsonView" hidden></div>
                            <textarea id="base64ResultView" readonly rows="5" hidden></textarea>
                        </div>
                    </div>
                </section>
            </main>
        </div>
        <footer>
            <p>
                &copy; <span id="currentYear"></span> Zanta's Utilities
                <button id="themeToggleBtn" title="切換主題">🌙</button>
            </p>
        </footer>
        <div id="toast"></div>

        <script type="module">
            import { chacha20poly1305 } from "https://cdn.jsdelivr.net/npm/@noble/ciphers/esm/chacha.js";

            document.addEventListener("DOMContentLoaded", () => {
                const app = {
                    elements: {
                        modeSelector: document.getElementById("modeSelector"),
                        encryptSection: document.getElementById("encrypt-section"),
                        decryptSection: document.getElementById("decrypt-section"),
                        mnemonic: document.getElementById("mnemonic"),
                        base64json: document.getElementById("base64json"),
                        passphraseEncrypt: document.getElementById("passphrase-encrypt"),
                        passphraseDecrypt: document.getElementById("passphrase-decrypt"),
                        togglePasswordEncrypt: document.getElementById("togglePasswordEncrypt"),
                        togglePasswordDecrypt: document.getElementById("togglePasswordDecrypt"),
                        algoSelectionGroup: document.getElementById("algoSelectionGroup"),
                        encryptBtn: document.getElementById("encryptBtn"),
                        decryptBtn: document.getElementById("decryptBtn"),
                        parseBtn: document.getElementById("parseBtn"),
                        copyBtn: document.getElementById("copyBtn"),
                        pasteBtn: document.getElementById("pasteBtn"),
                        resetBtn: document.getElementById("resetBtn"),
                        resultsArea: document.getElementById("results-area"),
                        output: document.getElementById("output"),
                        qrCanvas: document.getElementById("qrCanvas"),
                        jsonView: document.getElementById("jsonView"),
                        base64ResultView: document.getElementById("base64ResultView"),
                        paramsDisplayArea: document.getElementById("params-display-area"),
                        themeToggleBtn: document.getElementById("themeToggleBtn"),
                        currentYear: document.getElementById("currentYear"),
                        toast: document.getElementById("toast"),
                    },
                    state: {
                        currentMode: "encrypt",
                        selectedAlgorithm: "AES-GCM",
                        toastTimer: null,
                        lastDecryptedText: null,
                        lastEncryptedText: null,
                    },
                    constants: {
                        SALT_BYTES: 16,
                        IV_BYTES: 12,
                        TAG_LENGTH_BITS: 128,
                        NONCE_BYTES: 12,
                        KEY_LENGTH_BITS: 256,
                        DEFAULT_ITERATIONS: 2000000,
                        FALLBACK_ITERATIONS: 300000,
                        SVG_EYE_OPEN: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"/><path d="M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8zm8 3.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/></svg>`,
                        SVG_EYE_SLASH: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="m10.79 12.912-1.614-1.615a3.5 3.5 0 0 1-4.474-4.474l-2.06-2.06C.938 6.278 0 8 0 8s3 5.5 8 5.5a7.029 7.029 0 0 0 2.79-.588zM5.21 3.088A7.028 7.028 0 0 1 8 2.5c5 0 8 5.5 8 5.5s-.939 1.721-2.641 3.238l-2.062-2.062a3.5 3.5 0 0 0-4.474-4.474L5.21 3.089z"/><path d="M5.525 7.646a2.5 2.5 0 0 0 2.829 2.829l-2.83-2.829zm4.95.708-2.829-2.83a2.5 2.5 0 0 1 2.829 2.829zm3.171 6-12-12 .708-.708 12 12-.708.708z"/></svg>`,
                    },

                    init() {
                        this.elements.currentYear.textContent = new Date().getFullYear();
                        this.theme.init();
                        this.setupEventListeners();
                        this.ui.setMode("encrypt");
                        [this.elements.togglePasswordEncrypt, this.elements.togglePasswordDecrypt].forEach(
                            (el) => (el.innerHTML = this.constants.SVG_EYE_OPEN)
                        );
                    },

                    setupEventListeners() {
                        this.elements.themeToggleBtn.addEventListener("click", () => this.theme.toggle());
                        this.elements.modeSelector.addEventListener("click", (e) => {
                            const target = e.target.closest(".option");
                            if (target?.dataset.mode) this.ui.setMode(target.dataset.mode);
                        });
                        this.elements.algoSelectionGroup.addEventListener("click", (e) => {
                            const target = e.target.closest(".option");
                            if (target && !target.classList.contains("selected")) {
                                this.elements.algoSelectionGroup
                                    .querySelector(".selected")
                                    .classList.remove("selected");
                                target.classList.add("selected");
                                this.state.selectedAlgorithm = target.dataset.value;
                            }
                        });
                        this.elements.encryptBtn.addEventListener("click", () => this.crypto.encrypt());
                        this.elements.decryptBtn.addEventListener("click", () => this.crypto.decrypt());
                        this.elements.parseBtn.addEventListener("click", () => this.crypto.parseParameters());
                        this.elements.resetBtn.addEventListener("click", () => this.ui.resetAll());
                        this.elements.pasteBtn.addEventListener("click", () => this.utils.pasteTo("base64json"));
                        this.elements.copyBtn.addEventListener("click", () => this.utils.copyFromResult());
                        this.elements.togglePasswordEncrypt.addEventListener("click", () =>
                            this.ui.togglePasswordVisibility("passphraseEncrypt", "togglePasswordEncrypt")
                        );
                        this.elements.togglePasswordDecrypt.addEventListener("click", () =>
                            this.ui.togglePasswordVisibility("passphraseDecrypt", "togglePasswordDecrypt")
                        );
                    },

                    ui: {
                        setMode(mode) {
                            app.state.currentMode = mode;
                            const isEncrypt = mode === "encrypt";
                            app.elements.modeSelector.querySelector(".selected").classList.remove("selected");
                            app.elements.modeSelector.querySelector(`[data-mode="${mode}"]`).classList.add("selected");
                            app.elements.encryptSection.hidden = !isEncrypt;
                            app.elements.decryptSection.hidden = isEncrypt;
                            app.elements.pasteBtn.hidden = isEncrypt;
                            app.ui.resetAll();
                        },
                        setOutput(type, message) {
                            app.elements.resultsArea.hidden = false;
                            app.elements.output.className = `output-box ${type}`;
                            app.elements.output.innerHTML = message;
                        },
                        resetAll() {
                            ["mnemonic", "base64json", "passphraseEncrypt", "passphraseDecrypt"].forEach(
                                (id) => (app.elements[id].value = "")
                            );
                            this.resetResults();
                            app.elements.paramsDisplayArea.hidden = true; // Also hide params display on reset
                            app.state.lastDecryptedText = null;
                            app.state.lastEncryptedText = null;
                        },
                        resetResults() {
                            app.elements.resultsArea.hidden = true;
                            app.elements.qrCanvas
                                .getContext("2d")
                                .clearRect(0, 0, app.elements.qrCanvas.width, app.elements.qrCanvas.height);
                            app.elements.qrCanvas.hidden = true;
                            app.elements.jsonView.hidden = true;
                            app.elements.base64ResultView.hidden = true;
                            app.elements.copyBtn.hidden = true;
                        },
                        togglePasswordVisibility(inputId, iconId) {
                            const input = app.elements[inputId];
                            const icon = app.elements[iconId];
                            if (input.type === "password") {
                                input.type = "text";
                                icon.innerHTML = app.constants.SVG_EYE_SLASH;
                            } else {
                                input.type = "password";
                                icon.innerHTML = app.constants.SVG_EYE_OPEN;
                            }
                        },
                    },

                    crypto: {
                        toBase64: (u8) => btoa(String.fromCharCode.apply(null, u8)),
                        fromBase64: (b64) => Uint8Array.from(atob(b64), (c) => c.charCodeAt(0)),
                        async deriveKey(passphrase, salt, iterations) {
                            const enc = new TextEncoder();
                            return await crypto.subtle.importKey(
                                "raw",
                                enc.encode(passphrase),
                                { name: "PBKDF2" },
                                false,
                                ["deriveKey", "deriveBits"]
                            );
                        },
                        async encrypt() {
                            const mnemonic = app.elements.mnemonic.value.trim();
                            const passphrase = app.elements.passphraseEncrypt.value;
                            if (!mnemonic || !passphrase) {
                                app.ui.setOutput("error", "❌ 錯誤：明文和密碼短語不能為空。");
                                return;
                            }
                            app.ui.setOutput("info", "⏳ 正在加密，請稍候...");
                            await new Promise((r) => setTimeout(r, 50));
                            const startTime = performance.now();
                            try {
                                const enc = new TextEncoder();
                                const salt = crypto.getRandomValues(new Uint8Array(app.constants.SALT_BYTES));
                                const iterations = app.constants.DEFAULT_ITERATIONS;
                                const keyMaterial = await this.deriveKey(passphrase, salt, iterations);
                                let jsonOutput;
                                if (app.state.selectedAlgorithm === "AES-GCM") {
                                    const iv = crypto.getRandomValues(new Uint8Array(app.constants.IV_BYTES));
                                    const aesKey = await crypto.subtle.deriveKey(
                                        { name: "PBKDF2", salt, iterations, hash: "SHA-256" },
                                        keyMaterial,
                                        { name: "AES-GCM", length: app.constants.KEY_LENGTH_BITS },
                                        false,
                                        ["encrypt"]
                                    );
                                    const encrypted = await crypto.subtle.encrypt(
                                        { name: "AES-GCM", iv, tagLength: app.constants.TAG_LENGTH_BITS },
                                        aesKey,
                                        enc.encode(mnemonic)
                                    );
                                    jsonOutput = {
                                        keyDerivation: {
                                            name: "PBKDF2",
                                            salt: this.toBase64(salt),
                                            iterations,
                                            hash: "SHA-256",
                                        },
                                        encryption: {
                                            name: "AES-GCM",
                                            iv: this.toBase64(iv),
                                            ciphertext: this.toBase64(
                                                new Uint8Array(encrypted.slice(0, -app.constants.TAG_LENGTH_BITS / 8))
                                            ),
                                            tag: this.toBase64(
                                                new Uint8Array(encrypted.slice(-app.constants.TAG_LENGTH_BITS / 8))
                                            ),
                                            tagLength: app.constants.TAG_LENGTH_BITS,
                                        },
                                    };
                                } else {
                                    // ChaCha20-Poly1305
                                    const nonce = crypto.getRandomValues(new Uint8Array(app.constants.NONCE_BYTES));
                                    const chachaKeyBytes = new Uint8Array(
                                        await crypto.subtle.deriveBits(
                                            { name: "PBKDF2", salt, iterations, hash: "SHA-256" },
                                            keyMaterial,
                                            app.constants.KEY_LENGTH_BITS
                                        )
                                    );
                                    const aead = chacha20poly1305(chachaKeyBytes, nonce);
                                    const ciphertextWithTag = aead.encrypt(enc.encode(mnemonic));
                                    jsonOutput = {
                                        keyDerivation: {
                                            name: "PBKDF2",
                                            salt: this.toBase64(salt),
                                            iterations,
                                            hash: "SHA-256",
                                        },
                                        encryption: {
                                            name: "ChaCha20-Poly1305",
                                            nonce: this.toBase64(nonce),
                                            ciphertext: this.toBase64(ciphertextWithTag),
                                        },
                                    };
                                }
                                const outputBase64 = this.toBase64(
                                    new TextEncoder().encode(JSON.stringify(jsonOutput))
                                );
                                app.state.lastEncryptedText = outputBase64;
                                const duration = ((performance.now() - startTime) / 1000).toFixed(2);
                                app.ui.setOutput(
                                    "success",
                                    `✅ ${app.state.selectedAlgorithm} 加密成功！ (執行時間：${duration} 秒)`
                                );
                                app.elements.jsonView.textContent =
                                    "JSON 參數預覽:\n" + JSON.stringify(jsonOutput, null, 2);
                                app.elements.jsonView.hidden = false;
                                app.elements.base64ResultView.value = outputBase64;
                                app.elements.base64ResultView.hidden = false;
                                app.elements.qrCanvas.hidden = false;
                                QRCode.toCanvas(app.elements.qrCanvas, outputBase64, {
                                    errorCorrectionLevel: "H",
                                    width: 256,
                                });
                                app.elements.copyBtn.textContent = "複製 Base64 密文";
                                app.elements.copyBtn.hidden = false;
                            } catch (e) {
                                console.error("Encrypt failed:", e);
                                app.ui.setOutput("error", `❌ 加密失敗：${e.message}`);
                            }
                        },
                        async decrypt() {
                            const base64json = app.elements.base64json.value.trim();
                            const passphrase = app.elements.passphraseDecrypt.value;
                            if (!base64json || !passphrase) {
                                app.ui.setOutput("error", "❌ 錯誤：密文與密碼短語不能為空。");
                                return;
                            }
                            app.ui.setOutput("info", "⏳ 正在解密，請稍候...");
                            await new Promise((r) => setTimeout(r, 50));
                            const startTime = performance.now();
                            try {
                                const json = JSON.parse(new TextDecoder().decode(this.fromBase64(base64json)));
                                if (!json.keyDerivation || !json.encryption)
                                    throw new Error("無效或不支援的密文格式。");
                                const salt = this.fromBase64(json.keyDerivation.salt);
                                const iterations = json.keyDerivation.iterations;
                                const keyMaterial = await this.deriveKey(passphrase, salt, iterations);
                                let decryptedResult;
                                const encryptionName = json.encryption.name;
                                if (encryptionName === "AES-GCM") {
                                    const { iv, ciphertext, tag, tagLength } = json.encryption;
                                    const aesKey = await crypto.subtle.deriveKey(
                                        { name: "PBKDF2", salt, iterations, hash: "SHA-256" },
                                        keyMaterial,
                                        { name: "AES-GCM", length: app.constants.KEY_LENGTH_BITS },
                                        false,
                                        ["decrypt"]
                                    );
                                    const fullCipher = new Uint8Array([
                                        ...this.fromBase64(ciphertext),
                                        ...this.fromBase64(tag),
                                    ]);
                                    const decrypted = await crypto.subtle.decrypt(
                                        {
                                            name: "AES-GCM",
                                            iv: this.fromBase64(iv),
                                            tagLength: tagLength || app.constants.TAG_LENGTH_BITS,
                                        },
                                        aesKey,
                                        fullCipher
                                    );
                                    decryptedResult = new TextDecoder().decode(decrypted);
                                } else if (encryptionName === "ChaCha20-Poly1305") {
                                    const { nonce, ciphertext } = json.encryption;
                                    const chachaKeyBytes = new Uint8Array(
                                        await crypto.subtle.deriveBits(
                                            { name: "PBKDF2", salt, iterations, hash: "SHA-256" },
                                            keyMaterial,
                                            app.constants.KEY_LENGTH_BITS
                                        )
                                    );
                                    const aead = chacha20poly1305(chachaKeyBytes, this.fromBase64(nonce));
                                    decryptedResult = new TextDecoder().decode(
                                        aead.decrypt(this.fromBase64(ciphertext))
                                    );
                                } else {
                                    throw new Error("不支援的解密演算法。");
                                }
                                app.state.lastDecryptedText = decryptedResult;
                                const duration = ((performance.now() - startTime) / 1000).toFixed(2);
                                app.ui.setOutput(
                                    "success",
                                    `✅ ${encryptionName} 解密成功 (耗時 ${duration}s)<br><br><strong style="font-size: 1.1em;">${decryptedResult}</strong>`
                                );
                                app.elements.copyBtn.textContent = "複製解密結果";
                                app.elements.copyBtn.hidden = false;
                            } catch (e) {
                                console.error("Decrypt failed:", e);
                                const msg =
                                    e.name === "OperationError" || e.message.includes("tag")
                                        ? "密碼短語不正確，或密文已被竄改。"
                                        : e.message;
                                app.ui.setOutput("error", `❌ 解密失敗：${msg}`);
                            }
                        },
                        async parseParameters() {
                            const base64json = app.elements.base64json.value.trim();
                            if (!base64json) {
                                app.utils.showToast("請先貼上密文");
                                return;
                            }
                            try {
                                const json = JSON.parse(new TextDecoder().decode(this.fromBase64(base64json)));
                                const kd = json.keyDerivation;
                                const enc = json.encryption;
                                if (!kd || !enc) throw new Error("JSON 結構不符");
                                const displayEl = app.elements.paramsDisplayArea;
                                displayEl.innerHTML = `
                                    <p>金鑰衍生：<span>${kd.name} (${kd.hash}，${kd.iterations.toLocaleString(
                                    "en-US"
                                )} 迭代)</span></p>
                                    <p>加密演算法：<span>${enc.name}</span></p>
                                    <p style="color: var(--success-color);">狀態：<span>參數已載入 ✅</span></p>
                                `;
                                displayEl.hidden = false;
                                app.elements.resultsArea.hidden = true;
                            } catch (e) {
                                console.error("Parse failed:", e);
                                app.elements.paramsDisplayArea.innerHTML = `<p style="color: var(--error-color);">❌ 解析失敗：無效的 Base64 或 JSON 格式。</p>`;
                                app.elements.paramsDisplayArea.hidden = false;
                            }
                        },
                    },
                    utils: {
                        copyToClipboard(text, successMessage) {
                            navigator.clipboard
                                .writeText(text)
                                .then(() => {
                                    this.showToast(successMessage || "✅ 已複製到剪貼簿！");
                                })
                                .catch((err) => {
                                    console.error("Copy failed：", err);
                                    this.showToast("❌ 複製失敗");
                                });
                        },
                        pasteTo(elementId) {
                            navigator.clipboard
                                .readText()
                                .then((text) => {
                                    app.elements[elementId].value = text;
                                    this.showToast("✅ 已貼上內容！");
                                })
                                .catch((err) => {
                                    console.error("Paste failed：", err);
                                    this.showToast("❌ 貼上失敗或剪貼簿為空");
                                });
                        },
                        copyFromResult() {
                            if (app.state.currentMode === "encrypt" && app.state.lastEncryptedText) {
                                this.copyToClipboard(app.state.lastEncryptedText, "✅ 已複製 Base64 密文！");
                            } else if (app.state.currentMode === "decrypt" && app.state.lastDecryptedText) {
                                this.copyToClipboard(app.state.lastDecryptedText, "✅ 已複製解密結果！");
                            }
                        },
                        showToast(message) {
                            if (app.state.toastTimer) clearTimeout(app.state.toastTimer);
                            app.elements.toast.textContent = message;
                            app.elements.toast.className = "show";
                            app.state.toastTimer = setTimeout(() => {
                                app.elements.toast.className = "";
                                app.state.toastTimer = null;
                            }, 3000);
                        },
                    },
                    theme: {
                        init() {
                            const theme = localStorage.getItem("my-app-theme") || "dark";
                            this.apply(theme);
                        },
                        apply(theme) {
                            document.documentElement.setAttribute("data-theme", theme);
                            app.elements.themeToggleBtn.textContent = theme === "dark" ? "☀️" : "🌙";
                            localStorage.setItem("my-app-theme", theme);
                        },
                        toggle() {
                            const newTheme =
                                document.documentElement.getAttribute("data-theme") === "dark" ? "light" : "dark";
                            this.apply(newTheme);
                        },
                    },
                };
                app.init();
            });
        </script>
    </body>
</html>
